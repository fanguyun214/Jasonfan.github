{"posts":[{"title":"【读书笔记】软技能-代码之外的生存指南","content":"关于本书 书名：软技能 作者：John Sonmez 出版社：人民邮电出版社 阅读日期： 2016年07月 豆瓣评分：8.9 我的评分：☆☆☆☆ 内容简介 这是一本真正从“人”（而非技术也非管理）的角度关注软件开发人员自身发展的书。书中论述的内容既涉及生活习惯，又包括思维方式，凸显技术中“人”的因素，全面讲解软件行业从业人员所需知道的所有“软技能”。本书聚焦于软件开发人员生活的方方面面，从揭秘面试的流程到精耕细作出一份杀手级简历，从创建大受欢迎的博客到打造你，从提高自己工作效率到与如何与“拖延症”做斗争，甚至包括如何投资不动产，如何关注自己的健康。本书共分为职业篇、自我营销篇、学习篇、生产力篇、理财篇、健身篇、精神篇等七篇，概括了软件行业从业人员所需的“软技能”。通过阅读本书，软件工程人员、编程人员和其他技术人员能够积极思考自己的职业生涯，丰富自己的生活，让自己更接近成功。 作者简介 John Z. Sonmez是“Simple Programmer”网站的创始人，他不辞辛劳地追求着“将复杂问题转化为简单解决方案”的梦想。他为在线培训机构Pluralsight开发了50多门在线课程，涉及iOS、Android、.NET、Java和游戏开发等多个主题。 他是“Get Up and CODE”播客的主持人，在这里他讨论程序员健身；他还是“Entreprogrammers”播客的主持人，在这里他和其他三位开发者/企业家分享他们构建在线业务的真实故事。 John是软件开发人员的人生导师，他帮助软件工程师、程序员和其他专业技术人员推动事业进步，过上更充实的生活。他通过“化繁为简”的方法，赋予他们达成自身目标的力量。 书摘 • 工作是公司的，职业生涯是自己的 • 绝不要做他人都在做的，像经营企业一样经营自己 • 设定目标, 驱动小目标向着大目标前进 • 人际交往能力，学会如何与人打交道 - 认可他人、永远不要批评、换位思考、避开地雷人 • 破解面试之道 - 博客，社交，扩大影响力，推销自己 • 就业选择- 雇员、咨询师、创业者 • 你是哪类开发人员 - 专业化（多博专精） • 攀登晋升阶梯 - 承担责任、保证曝光度、自学、分享、 • 成为专业人士 - 严肃对待，保持专业习惯、追求品质、完善自我、坚守正道 • 赢得自由(如何辞职) - 开源节流、以副业的方式创业 • 成为自有职业者 - 获取客户，时薪+额外费用，应该为全职时薪2倍 • 开始创业 - 获得投资、谨慎出让股权 • 远程工作的生存策略 - 时间管理、自我激励、孤独感 • 假装自己能成功 - 有目的的将自己置与困境、破釜沉舟的勇气、自信而不自负、拥抱新问题 • 单调乏味的简历 - 雇一个简历写手、招聘者意见 • 请勿陷入对技术的狂热之中 - 保持开放心态 • 码农的营销课 - 提供自我价值、包装想法比想法本身更重要、塑造好自己形象 • 打造引人注目的品牌 - 品牌核心信息、视觉符号、一致性、曝光率 • 创建大获成功的博客 - 定期更新、持之以恒 • 为他人增加价值 - 帮别人解决问题 • 擅于运用社交媒体 - 专业化 • 演讲、培训和报告 - 做说话的极客、从团队分享开始、培训 • 著书立说，吸引追随者 • 百折不挠、越挫越勇 - 别太在意别人想法和眼光、别害怕自己出丑、勇敢的走出去 • 学习怎样学习、如何自我教育 - 纸上得来终觉浅、最好的办法就是付诸于实践，立即参与 • 十步学习法 1、了解全部 -&gt; 2、确定范围 -&gt; 3、定义目标 -&gt; 4、寻找资源 -&gt; 5、创建学习计划 -&gt; 6、筛选资源 -&gt; 7、开始学习，浅尝截止 -&gt; 8、动手操作，边玩边学 -&gt; 9、全面掌握，学以致用 -&gt; 10、乐为人师，融会贯通 • 十步学习法 - 第一步到第六步这些步骤只做一次(OKR) • 十步学习法 - 第七步到第十步循环往复 • 寻找导师 - 找到你的尤达 • 开山收徒 - 成为尤达一样的大师 • 传道授业 - 若要学知识，必得为人师、知其然知其所以然、以谦虚的视角观察问题，以权威的视角诠释问题、心态谦卑，信心满满 • 你学要一个学位吗、还是可以对此忽略 - 学位是有优势的 • 发现自己的只是短板 • 一切始于专注 - 不要频繁切换任务，几种精力处理一件事情，将任务按照分类组合起来，高效处理 • 生产力提升计划 - 番茄工作法、看法计划。季度计划 • 番茄工作法 - 规划，追踪，记录，处理，以及可视化 • 定额工作法 - 承诺是完成定额工作法的核心 • 对自己负责 - 高效自我驱动 • 要不要多任务并行 - 批量处理任务如邮件，效率更高， • 职业倦怠：我已找到解药 - 咬紧牙冠，经历痛苦、穿过倦怠的那堵墙，找到墙后的金子 • 时间是怎样被浪费掉的 - 戒掉电视、浪费时间、潜移默化思想、毫无意义；控制社交媒体 • 形成惯例的重要性 • 培养习惯、刷新你的代码 -找到坏习惯、改为好习惯、试着从小事做起 • 分解任务、如何吃掉一头大象 - 任务越大越难明确定义、分解任务、精确定义、减少完成难度 • 努力工作的价值、你为什么总是逃避努力工作 - 努力工作是成功的必要条件、工作的时候要既聪明又努力并需要毅力 • 任何行动都比不采取行动好 - 都没采取行动，怎么能指望有事发生那？跑起来的汽车更容易转向 • 怎样支配你的薪水 - 拒绝短期思维、长远打算、开源节流、不把薪水浪费在负债上、学会理财投资 • 怎样进行薪酬谈判 - 打造个人品牌、获得工作的方式、先出价输、多拿几个offer • 期权：所有乐趣之所在 • 房地产投资面面观 - 低风险，高负债、房地产是很好的投资，以租养贷 • 你真的了解自己的退休计划吗 - 开源节流、用来投资、以资本获利，养下蛋公鸡、真正财务自由的方法用钱生钱 • 债务的危害 - 先还高利率债务，再存钱、存款利率低于贷款利率 • 我是如何做到33岁退休的 - 财务自由、在不想工作的时候不工作 • 为什么要破解自己的健康密码 - 健身要自己更有魅力、自信心 • 设定你的健身目标 - 把健身作为优先计划 • 热力学、热量和你 - 热量影响体重 • 动力：让你的屁股离开椅子 • 如何增长肌肉 - 合理膳食、摄入蛋白质 • 启动跑步程序 • 站立式办公及其他窍门 • 高科技健身装备：极客现身 • 心灵是如何影响身体的 - 无形控制有形、心态很重要 • 拥有正确的心态：重新启动 - 保持积极的心态、心态影响做事效率、劳逸结合才能保持良好的心态 • 构建一个积极的自我形象，规划你的大脑 - 不要被大脑中自我想象束缚、假装自己能成功，打破自我潜意识、把自己能转变成任何想要的形象 • 积极面对失败 - 别把失败看的太重、失败不是终点、你是否要为自己最终拥有的东西而战斗、把失败看做经验，而不是全盘否定、学会拥抱失败、接受失败、拥抱失败、不要停止那些有挑战或有危险的事情、走出去有目的的把自己放在有挑战的环境 • 结束语 - 塑造自己的自我价值、生活原本比朝9晚5的生活更精彩 • 如果你能写代码，你就能理解金融 - 货币是价值的体现，货币的总量决定货币价值；通货膨胀：货币价值变小，钱贬值，物价上升，减轻债务；通货紧缩：货币价值变大，钱升值，物价降低，增加债务；中央银行控制货币总量，抑制通胀或者通缩，抑制经济过热或过冷，控制法定存款准备金；普通银行靠把存款贷款给别人，赚取利率差价，银行可以互相拆借；金融体系的基础，风险、收益、流动性； • 股市是如何运作的：系统的游戏规则 - 只是节俭是不够的，要让钱动起来，让钱生钱、投资；股市存在的目的为了让投资者更加方便的买入卖出股票；企业上市发行股票是为了筹集资金；交易量决定股票的流动性；低买高卖原则；做多：就是你看好大米会涨价，买入或借入大米囤起来，等大米价格上涨了就卖出去赚差价；做空：就是你看好大米会降价，跟大米老板借大米，然后卖出去换成钱，等大米降价再用钱买大米还给大米老板，赚取差价 • 垃圾进来垃圾出去：饮食和营养基础知识 - 碳水化合物、蛋白质、脂肪构成了我们摄入食物的主要组成部分；其他必须维生素；纤维；矿物质；水；深度加工的食品含有更多的糖分和防腐剂；清楚自己的饮食结构； • 如何吃出健康来：披萨并不是一个食物组 - 控制热量总数；控制糖量摄入； 推荐书单 • 习惯的力量 • 精益创业 • 驱动力 • 积极思考就是力量 • The War of Art • 人性的弱点 • 思考致富 • 心理控制方法 • 积极思考就是力量 • 阿特拉耸耸肩 软件开发类书单 • 代码大全 • 代码整洁之道 • Head First设计模式 投资类书单 • The Millionaire Real Estate Investor • 穷爸爸富爸爸 • No-Hype Options Trading:Myths,Realities, and Straategies That Really Work ","link":"https://fanguyun214.github.io/post/du-shu-bi-ji-ruan-ji-neng-dai-ma-zhi-wai-de-sheng-cun-zhi-nan/"},{"title":"Docker&k8s入门","content":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Dopcker常用命令 docker pull image - 拉取Image docker container ls -a - 列出所有容器 docker run -it centos - 交互式运行 docker run -d containerid - 后台执行 docker run -p 80 imageid - 将容器的80端口随机映射到宿主机的一个端口上 docker run -p 8000:80 imageid - 将容器的80端口映射到宿主机的8000端口上 docker run --name web image - 以别名启动Image docker container rm id - 删除container docker imgae rm id - 删除Image docker container ls -aq - 列出所有container ID docker rm $(docker container ls -aq) - 删除所有container docker rm $(docker coontainer ls -f &quot;status=exited&quot; -q) - 删除所有已退出的container docker commit containerName repository - 基于container构建Image（不提倡，建议通过Dockfile） docker history imageid - Image历史记录 docker build -t repository . - 基于当前目录Dockerfile构建Image more Dockerfile - 查看Dockerfile docker ps -a - 显示所有的容器，包括未运行的 docker run -d --link redis --name flask-redis -e REDIS_HOST=redis -p 6000:5000 jasonfan123/flask-redis - containei互相访问设置（-e设置环境变量） docker rm -f container - 强制停止并删除container Dokcer Container操作 docker exex -it containerid /bin/bash - 进入指定容器执行指定命令 docker stop containerid - 停止运行中的container docker start containerid - 启动停止的container docker inspect containerid - container详细信息 Dockerfile基本语法 # FROM - 基础镜像，尽量使用官方Image作为BaseImage FROM scratch # - 制作baseImage（不使用任何Image） FROM centos # - 使用baseImage # LABEL - Image信息描述,Metadata不可少 LABEL version=&quot;1.0&quot; LABEL description=&quot;this is des&quot; # RUN - 执行命令并创建新的Image Layer，避免无用分层，合并多条命令为一行用&amp;&amp;， 复杂的可用反斜杠\\换行 RUN yum update &amp;&amp; yum install -y vim \\ python-dev # - 反斜杆换行 RUN apt-get update &amp;&amp; apt-get install -y perl &amp;&amp; rm -rf \\ var/lib/apt/list/* # - 注意清理cache # WORKDIR - 设定当前工作目录,用WORKDIR,不要用RUN cd，尽量使用绝对目录 WORKDIR /test # - 如果没有会自动创建test目录 WORKDIR demo RUN pwd # - 输出结果应该是/test/demo # ADD &amp;&amp; COPY - 把本地环境文件添加到docker Image中 # ADD or COPY - 大部分情况COPY优于ADD，ADD除了COPY还有额外功能（解压），添加远程文件/目录请使用curl或者wget ADD hello / ADD test.tar.gz / # - 添加到根目录并解压 WORKDIR /root ADD hello test/ - /root/test/hello WORKDIR /ROOT COPY hello test/ # ENV - 设置环境常量，尽量使用ENV增加可维护性 ENV MYSQL_VERSION 5.6 # - 设置常量 RUN apt-get install -y mysql-server=&quot;${MYSQL_VERSION}&quot; \\ &amp;&amp; rm -rf /var/lib/apt/lists/* # - 引用常量 # VOLUME &amp;&amp; EXPOER - 存储和网络 # CMD &amp;&amp; ENTRYPOINT # CMD - 设置容器启动后默认执行的命令和参数，如果docker run指定了其他命令，CMD命令被忽略，如果定义了多个CMD，只有最后一个会执行 # ENTRYPOINT - 设置容器启动时运行的命令，让容器以应用程序或者服务的形式运行，不会被忽略一定会执行，最佳实践：写一个shell脚本作为entrypoint COPY docker-entrypoint.sh /usr/local/bin/ ENTRYPOINT [&quot;docker-entrypoint.sh&quot;] # Shell和Exec格式 # Shell格式 - 默认shell RUN apt-get install -y vim CMD echo &quot;hello docker&quot; ENTRYPOINT echo “hello docker” # Exec格式 - 指定 RUN [&quot;apt-get&quot;,&quot;install&quot;, &quot;-y&quot;,&quot;vim&quot;] CMD [&quot;/bin/echo&quot;, &quot;hello docker&quot;] ENTRYPOINT [&quot;/bin/echo&quot;, &quot;hello docker&quot;] Docker Image Push docker login docker push jasonfan123/centos-vim-new:latest 数据持久化 # Dockerfile VOLUME # volume绕过container的文件系统，直接将数据写到host机器上，只是volume是被docker管理的，docker下所有的volume都在host机器上的指定目录下/var/lib/docker/volumes # VOLUME /var/lib/mysql docker volume ls - 查看volume docker run -v mysql:/var/lib/mysql - 重命名volume:路劲 # Bind Mouting docker -v $(pwd):/root/aaa - 将宿主机当前目录映射到容器目录 Docker Compose 多容器应用：拉取多个image、创建多个container、要管理这些container Docker Compose 批处理，基于Docker的命令行工具，通过一个yml文件定义多容器的Docker应用，通过一条命令就可以根据yml文件去创建或者管理这个多个容器 # 默认名字：docker-compose.yml # 三大概念： Services、Networks、Volumes # Services： 一个service代表一个container，可以从远程拉取iamge，也可以从本地的dockerfile build出来image service的启动类似docker run，可以指定network和volume # docker-compose up - 启动多有yml文件容器，默认文件docker-compose.yml # docker-compose up -d - 后台运行 # docker-compose -f xx.yml up - 指定yml文件 # docker-compose ps - 列出services # docker-compose start - 停止 # docker-compose stop - 停止 # docker-compose down - 停止并删除 # docker-compose exec mysql bash - 进入容器并执行 # docker-compose up --scale service=3 -d - 给service指定容器数量 (haproxy) # wordprss &amp; mysql 示例 version: '3' services: wordpress: image: wordpress ports: - 8080:80 environment: WORDPRESS_DB_HOST: mysql WORDPRESS_DB_PASSWORD: root networks: - my-bridge mysql: image: mysql environment: MYSQL_ROOT_PASSWORD: root MYSQL_DATABASE: wordpress volumes: - mysql-data:/var/lib/mysql networks: - my-bridge volumes: mysql-data: networks: my-bridge: driver: bridge Swarm Mode 集成在docker中的容器编排工具 基于Docker的devops ","link":"https://fanguyun214.github.io/post/dockerandk8s-ru-men/"},{"title":"Nrwl/NX工作区中lib差异化配置","content":"基于environment在业务代码中实现不同环境下的差异化配置 新增多环境environment 1、新增特定环境配置 # 如 environment.staging.ts export const environment = { production: true, staging: true, apiUrl: 'http://my-prod-url' }; 2、在angular.json 中添加 staging 环境配置 &quot;configurations&quot;: { &quot;production&quot;: { ... }, &quot;staging&quot;: { &quot;fileReplacements&quot;: [ { &quot;replace&quot;: &quot;src/environments/environment.ts&quot;, &quot;with&quot;: &quot;src/environments/environment.staging.ts&quot; } ] } } 3. 基于staging的构建 ng build --configuration=staging 基于InjectionToken的DI（依赖注入） 1、在lib中创建目录app-config及index.ts // index.ts 声明InjectionToken import { InjectionToken } from '@angular/core'; export const APP_CONFIG = new InjectionToken('Application config'); 2、修改tsconfig.json添加导出路径 &quot;paths&quot;: { &quot;@app-workspace/app-config&quot;: [&quot;libs/app-config/index.ts&quot;] } 3、app.module.ts中providers注入 import { APP_CONFIG } from '@app-workspace/app-config'; import { environment } from '../environments/environment'; @NgModule({ declarations: [AppComponent], imports: [ BrowserModule, AppRoutingModule, ], providers: [ { provide: APP_CONFIG, useValue: environment} ], bootstrap: [AppComponent] }) export class AppModule {} 4、lib中使用 import { APP_CONFIG } from '@app-workspace/app-config'; import { Inject, Injectable } from '@angular/core'; @Injectable() export class AuthService { constructor( @Inject(APP_CONFIG) private appConfig: any ) { console.log(this.appConfig.apiUrl); } } ","link":"https://fanguyun214.github.io/post/ji-yu-nrwlnx-de-gong-zuo-qu-zhong-lib-zhong-ru-he-yin-yong-environmentts-chai-yi-hua-pei-zhi/"},{"title":"docz-记录你的东西从未如此简单","content":"Docz基于MDX，MDX是Markdown + JSX，它为Markdown带来了组件世界。 MDX使得可以在Markdown样式的文件中导入和使用组件。 Docz充分利用了这一点，并提供了许多内置组件，这些组件可以增强和加快文档工作流程。Docz输出静态站点，你可以使用任何静态网站托管提供商来部署生成的docz网站。 特性 基于Gatsby，快速的开发/构建体验 简单配置 自定义主题 基于MDX 插件化 TypeScript支持 基本使用 安装 yarn add docz react react-dom --dev 创建.mdx文件 --- name: Button route: / --- import { Playground, Props } from 'docz' import { Button } from './' # Button &lt;Props of={Button} /&gt; ## Basic usage &lt;Playground&gt; &lt;Button&gt;Click me&lt;/Button&gt; &lt;Button kind=&quot;secondary&quot;&gt;Click me&lt;/Button&gt; &lt;/Playground&gt; dev yarn docz dev build yarn docz构建将在.docz/dist/中生成一个静态站点。 通过在doczrc.js中或在命令行中提供dest字段的路径来使yarn docz build到另一个目录：yarn docz build --dest docs-site-directory。 yarn docz build 其他 创建新应用 npx create-docz-app my-docz-app # or yarn create docz-app my-docz-app --example typescript 添加到现有项目 yarn add docz # react react-dom # or npm install docz # react react-dom 内置组件 使用组件，可以在可实时编辑的游乐场中渲染组件，并直接查看所使用代码的输出： # Playground Component --- name: Button route: / --- import { Playground } from 'docz' import { Button } from './Button' # Button ## Basic usage &lt;Playground&gt; &lt;Button&gt;Click me&lt;/Button&gt; &lt;Button kind=&quot;secondary&quot;&gt;Click me&lt;/Button&gt; &lt;/Playground&gt; 文档设置 --- name: My Document route: /custom-route menu: Documents --- name文档的名称，用作页面标题 route *（可选）*到文档生成页面的路径或路径。例如/docs/my-component menu*（可选）*包含文档的菜单。文档分组到一个菜单中 ","link":"https://fanguyun214.github.io/post/docz-ji-lu-ni-de-dong-xi-cong-wei-ru-ci-jian-dan/"},{"title":"前端性能优化指南","content":"性能优化一直以来都是前端工程领域中的一个重要部分。网站应用的性能（加载速度、交互流畅度）优化对于提高用户留存、转化率等都有积极影响。可以理解为，提升你的网站性能，就是提升你的业务数据（甚至是业务收入）。 性能优化广义上会包含前端优化和后端优化。后端优化的关注点更多的时候是在增加资源利用率、降低资源成本以及提高稳定性上。相较于后端，前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。 目的 让页面加载的更快 对用户操作响应更及时，为用户带来更好的使用体验 减少请求，降低服务器负荷，节省资源 原则 建立性能优化意识 目标：比你最快的竞争对手快至少20% 选择正确的指标 从具有代表性的用户使用的设备收集数据 深入理解业务 如何衡量 以用户为中心的性能指标： ​ 1、哪些指标能够最准确的衡量用户所感受到的性能？ ​ 2、如何针对实际用户来衡量这些指标？ ​ 3、如何解读衡量结果以确定应用是否速度快？ ​ 4、了解应用的实际用户性能之后，如何避免性能下降并在未来提高性能？ 基本概述（雅虎前端优化35条） 内容 1、尽量减少HTTP请求数 80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本等等。减少组件数必然能够减少页面提交的HTTP请求数，这是让页面更快的关键。 合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。 2、减少DNS查找 3、避免重定向 4、让Ajax可缓存 5、延迟加载 6、预加载 7、减少DOM元素数量 8、划分到不同域名 9、尽量减少Iframe的使用 10、避免404错误 服务器 1、使用CDN 2、添加Expires或Cache-Control响应头，使用缓存 3、启用Gzip 4、配置Etag 5、尽早输出缓存 6、Ajax请求使用Get 7、避免src、href为空 Cookie 1、减少cookie使用 2、静态资源使用无cookie域名 CSS 1、把样式表放在head中 2、不要使用CSS表达式 3、使用代替@import 4、不要使用filter(已废弃，可用来解决IE老版本png背景透明问题) Javascript 1、脚本放在页面底部 2、使用外部JS和CSS 3、压缩JS和CSS 4、移除重复脚本 5、减少DOM操作 6、使用高效的事件处理 图片 1、优化图片 2、使用CSS Sprite 3、不要在HTML中缩放图片 4、使用体积小、可缓存的favicon.ico 移动端 1、保证所有组件小于25K 2、打包内容为分段（multipart）文档 性能数据采集/监控 W3C Navigation Timing API的性能指标 W3C性能小组引入了 Navigation Timing API ，实现了自动、精准的页面性能打点；开发者可以通过 window.performance 属性获取。 performance.timing 接口（定义了从 navigationStart 至 loadEventEnd 的 21 个只读属性） performance.navigation（定义了当前文档的导航信息，比如是重载还是向前向后等） W3C Navigation Timing V2处理模型图: 从当前浏览器窗口卸载旧页面开始，到新页面加载完成，整个过程一共被切分为 9 个小块：提示卸载旧文档、重定向/卸载、应用缓存、DNS 解析、TCP 握手、HTTP 请求处理、HTTP 响应处理、DOM 处理、文档装载完成。每个小块的首尾、中间做事件分界，取 Unix 时间戳，两两事件之间计算时间差，从而获取中间过程的耗时（精确到毫秒级别）。 指标解读: 字段 说明 navigationStart 当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性 unloadEventStart 如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0 unloadEventEnd 如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0 redirectStart 返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0 redirectEnd 返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0 fetchStart 返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生 domainLookupStart 返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值 domainLookupEnd 返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值 connectStart 返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值 connectEnd 返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束 secureConnectionStart 返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0 requestStart 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳 responseStart 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳 responseEnd 返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳 domLoading 返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳 domInteractive 返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳 domContentLoadedEventStart 返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳 domContentLoadedEventEnd 返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳 domComplete 返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳 loadEventStart 返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0 loadEventEnd 返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0 关键性能指标 字段 描述 计算公式 备注 First Meaningful Paint (FMP) 首屏时间 无 无 fpt First Paint Time，首次渲染时间（白屏时间） responseEnd - fetchStart 从请求开始到浏览器开始解析第一批HTML文档字节的时间差 tti Time to Interact，首次可交互时间 domInteractive - fetchStart 浏览器完成所有HTML解析并且完成DOM构建，此时浏览器开始加载资源 ready HTML加载完成时间， 即DOM Ready时间 domContentLoadEventEnd - fetchStart 如果页面有同步执行的JS，则同步JS执行时间 = ready - tti load 页面完全加载时间 loadEventStart - fetchStart load = 首次渲染时间 + DOM解析耗时 + 同步JS执行 + 资源加载耗时 firstbyte 首包时间 responseStart - domainLookupStart 无 区间段耗时 字段 描述 计算公式 dns DNS查询耗时 domainLookupEnd - domainLookupStart 无 tcp TCP连接耗时 connectEnd - connectStart 无 ttfb Time to First Byte（TTFB），请求响应耗时。 responseStart - requestStart TTFB有多种计算方式 trans 内容传输耗时 responseEnd - responseStart 无 dom DOM解析耗时 domInteractive - responseEnd 无 res 资源加载耗时 loadEventStart - domContentLoadedEventEnd 表示页面中的同步加载资源 ssl SSL安全连接耗时 connectEnd - secureConnectionStart 只在HTTPS下有效 注意点 通过window.performance.timing所获的的页面渲染所相关的数据，在单页应用中改变了url但不刷新页面的情况下是不会更新的。因此如果仅仅通过该api是无法获得每一个子路由所对应的页面渲染的时间。如果需要上报切换路由情况下每一个子页面重新render的时间，需要自定义上报。 通过window.performance.getEntries()所获取的资源加载和异步请求所相关的数据，在页面切换路由的时候会重新的计算，可以实现自动的上报。 SPA模式 Navigation Timing API可以监控大部分前端页面的性能。但随着SPA模式的盛行，类似Angular/Reac/Vuet等框架的普及，页面内容渲染的时机被改变了，W3C标准无法完全满足原来的监控意义。以Chrome为首的浏览器一直在推动以用户为中心的性能指标，并且逐步开放API。如lighthouse，Web Vitals等提供浏览器插件/命令行工具/NPM包。 关注点 体验 指标 是否发生 首次绘制(FP)首次内容绘制(FCP) 是否有用 首次有效绘制(FMP)/主角元素计时 是否可用 可交互事件(TTI) 是否令人愉快 耗时较长的任务(在技术上不存在耗时较长的任务) 关键指标 指标 说明 FP(First Paint) 页面在导航后首次呈现出不同于导航前内容的时间点 FCP(First Contentful Paint) 首次绘制任何文本，图像，非空白canvas或SVG的时间点 TTI(Time to Interactive) 从页面开始加载到页面主要资源加载之间的时间 LCP(Largest Contentful Paint) 可视区域“内容”最大的可见元素开始出现在页面上的时间点 CLS(Cumulative Layout Shift) 表示用户经历的意外 layout 偏移的频率 TBT(Total Blocking Time) 表示从 FCP 到 TTI 之间，所有 long task 的阻塞时间之和 FP和FCP可能是相同的时间，也可能FP先于FCP。下图展示了 FP 和 FCP 的区别: 通过 window.performance.getEntriesByType('paint') 获取两个时间点的值。 performance.getEntriesByType('paint'); LCP可以通过 Chrome 的 PerformanceObserver API 计算它: // Create a variable to hold the latest LCP value (since it can change). let lcp; // Create the PerformanceObserver instance. const po = new PerformanceObserver((entryList) =&gt; { const entries = entryList.getEntries(); const lastEntry = entries[entries.length - 1]; // Update `lcp` to the latest value, using `renderTime` if it's available, // otherwise using `loadTime`. (Note: `renderTime` may not be available if // the element is an image and it's loaded cross-origin without the // `Timing-Allow-Origin` header.) lcp = lastEntry.renderTime || lastEntry.loadTime; }); // Observe entries of type `largest-contentful-paint`, including buffered // entries, i.e. entries that occurred before calling `observe()`. po.observe({type: 'largest-contentful-paint', buffered: true}); // Send the latest LCP value to your analytics server once the user // leaves the tab. addEventListener('visibilitychange', function fn() { if (lcp &amp;&amp; document.visibilityState === 'hidden') { console.log('LCP:', lcp); removeEventListener('visibilitychange', fn, true); } }, true); 优化 FP/FCP 从文档的 &lt;head&gt; 中移除任何阻塞渲染的脚本或样式表，可以减少首次绘制和首次内容绘制前的等待时间。 花时间确定向用户指出“正在发生”所需的最小样式集，并将其内联到 &lt;head&gt; 中（或者使用 HTTP/2 服务器推送)），即可实现极短的首次绘制时间。 应用 shell 模式可以很好地说明如何针对渐进式网页应用实现这一点。 优化 FMP/TTI 确定页面上最关键的界面元素（主角元素）之后，您应确保初始脚本加载仅包含渲染这些元素并使其可交互所需的代码。 初始 JavaScript 软件包中所包含的任何与主角元素无关的代码都会延长可交互时间。 没有理由强迫用户设备下载并解析当前不需要的 JavaScript 代码。 一般来说，您应该尽可能缩短 FMP 与 TTI 之间的时间。 如果无法最大限度缩短此时间，界面绝对有必要明确指出页面尚不可交互。 对于用户来说，其中一种最令人失望的体验就是点按元素后毫无反应。 避免出现耗时较长的任务 拆分代码并按照优先顺序排列要加载的代码，不仅可以缩短页面可交互时间，还可以减少耗时较长的任务，然后即有希望减少输入延迟及慢速帧。 除了将代码拆分为多个单独的文件之外，您还可将大型同步代码块拆分为较小的块，以便以异步方式执行，或者推迟到下一空闲点。 以异步方式在较小的块中执行此逻辑，可在主线程中留出空间，供浏览器响应用户输入。 最后，您应确保测试第三方代码，并对任何低速运行的代码追责。 产生大量耗时较长任务的第三方广告或跟踪脚本对您业务的伤害大于帮助。 数据上报 使用的img标签get请求 不存在AJAX跨域问题，可做跨源的请求 很古老的标签，没有浏览器兼容性问题 var i = new Image(); i.onload = i.onerror = i.onabort = function () { i = i.onload = i.onerror = i.onabort = null; } i.src = url; navigator.sendBeacon 大部分现代浏览器都支持 navigator.sendBeacon方法。这个方法可以用来发送一些统计和诊断的小量数据，特别适合上报统计的场景。 数据可靠，浏览器关闭请求也照样能发 异步执行，不会影响下一页面的加载 API使用简单 window.addEventListener('unload', logData, false); function logData() { navigator.sendBeacon(&quot;/log&quot;, analyticsData); } 当浏览器支持sendBeacon方法，优先使用该方法，使用img方式降级上报。 参考 以用户为中心的性能指标 解读新一代 Web 性能体验和质量指标 ","link":"https://fanguyun214.github.io/post/qian-duan-xing-neng-you-hua-zhi-nan/"},{"title":"NgRx使用","content":"NgRx是用于在Angular中构建反应式应用程序的框架。NgRx提供状态管理，副作用隔离，实体集合管理，路由器绑定，代码生成以及开发人员工具，这些工具可增强开发人员在构建许多不同类型的应用程序时的体验。 为什么要使用NgRx进行状态管理？ NgRx通过存储单个状态和使用操作来表达状态更改，从而提供了用于创建可维护的显式应用程序的状态管理。 可序列化 通过规范化状态变化并将其传递给可观察对象，NgRx提供了可序列化性，并确保状态可预测地存储。这样可以将状态保存到外部存储，例如localStorage。 此外，它还允许从Store Devtools检查，下载，上传和调度操作。 类型安全 依靠TypeScript编译器来保证程序正确性，从而在整个体系结构中提高了类型安全性。 封装 使用NgRx Effects和Store，可以将与外部资源副作用（例如网络请求，Web套接字和任何业务逻辑）的任何交互都与UI隔离。这种隔离允许使用更多纯净和简单的组件，并保持单一职责原则。 可测试的 由于Store使用纯函数来更改状态和从状态中选择数据，并且能够将副作用与UI隔离，因此测试变得非常简单。NgRx还提供诸如provideMockStore和provideMockActions用于隔离测试的测试设置，并提供更好的测试体验。 性能 存储建立在单个不变的数据状态上，使用OnPush策略使更改检测变成一项非常容易的任务。NgRx还由可记忆的选择器功能提供支持，这些选择器功能可优化状态查询计算。 何时应使用NgRx进行状态管理 当管理服务中的状态不再足够时，在构建具有大量用户交互和多个数据源的应用程序时，可能会使用NgRx。 SHARI原则可以回答“我何时需要NgRx”这个问题： Shared：由许多组件和服务的访问的状态。 Hydrated：从外部存储持久化。 Available：状态，需要时可用重新进入路线。 Retrieved：必须附带副作用的状态。 Impacted：受其他来源的行动影响的状态。 @ngrx/store Store是受Redux启发的RxJS支持的Angular应用程序状态管理。 Store是一个受控状态容器，旨在帮助在Angular上编写高性能，一致的应用程序。 关键概念 Actions: 动作描述从组件和服务调度的唯一事件 State: 状态更改由称为简化器的纯函数处理，这些函数采用当前状态和最新操作来计算新状态。 Selectors: 选择器是用于选择，导出和组成状态块的纯函数。 State是通过Store访问的，状态是可观察的，行为是观察者。 状态流 下图表示NgRx中应用程序状态的总体一般流程： 安装 // use npm npm install @ngrx/store --save // use yarn yarn add @ngrx/store // use ng add ng add @ngrx/store 示例 以下教程向您展示如何管理计数器的状态，以及如何在Angular组件中选择和显示它: 1、创建一个名为counter.actions.ts的新文件，以描述递增，递减和重置其值的计数器动作。 // src/app/counter.actions.ts import { createAction } from '@ngrx/store'; export const increment = createAction('[Counter Component] Increment'); export const decrement = createAction('[Counter Component] Decrement'); export const reset = createAction('[Counter Component] Reset'); 2、根据提供的操作对reducer函数进行细化以处理计数器值的更改 // src/app/counter.reducer.ts import { createReducer, on } from '@ngrx/store'; import { increment, decrement, reset } from './counter.actions'; export const initialState = 0; const _counterReducer = createReducer(initialState, on(increment, state =&gt; state + 1), on(decrement, state =&gt; state - 1), on(reset, state =&gt; 0), ); export function counterReducer(state, action) { return _counterReducer(state, action); } 3、从@ ngrx / store和counter.reducer文件导入StoreModule。 // src/app/app.module.ts (imports) import { StoreModule } from '@ngrx/store'; import { counterReducer } from './counter.reducer'; 4、在AppModule的imports数组中添加StoreModule.forRoot函数，其中包含一个对象，该对象包含计数和管理计数器状态的counterReducer。 StoreModule.forRoot（）方法注册在整个应用程序中访问商店所需的全局提供程序。 // src/app/app.module.ts (StoreModule) import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import { StoreModule } from '@ngrx/store'; import { counterReducer } from './counter.reducer'; @NgModule({ declarations: [AppComponent], imports: [ BrowserModule, StoreModule.forRoot({ count: counterReducer }) ], providers: [], bootstrap: [AppComponent], }) export class AppModule {} 5、在app文件夹中创建一个名为my-counter的新组件。将存储服务注入到组件中以分派计数器动作，并使用select运算符从状态中选择数据。 使用按钮更新MyCounterComponent模板，以调用递增，递减和重置方法。使用异步管道订阅可观察的count。 // src/app/my-counter/my-counter.component.html &lt;button id=&quot;increment&quot; (click)=&quot;increment()&quot;&gt;Increment&lt;/button&gt; &lt;div&gt;Current Count: {{ count$ | async }}&lt;/div&gt; &lt;button id=&quot;decrement&quot; (click)=&quot;decrement()&quot;&gt;Decrement&lt;/button&gt; &lt;button id=&quot;reset&quot; (click)=&quot;reset()&quot;&gt;Reset Counter&lt;/button&gt; 使用用于计数的选择器和用于调度Increment，Decrement和Reset操作的方法更新MyCounterComponent类 // src/app/my-counter/my-counter.component.ts import { Component } from '@angular/core'; import { Store, select } from '@ngrx/store'; import { Observable } from 'rxjs'; import { increment, decrement, reset } from '../counter.actions'; @Component({ selector: 'app-my-counter', templateUrl: './my-counter.component.html', styleUrls: ['./my-counter.component.css'], }) export class MyCounterComponent { count$: Observable&lt;number&gt;; constructor(private store: Store&lt;{ count: number }&gt;) { this.count$ = store.pipe(select('count')); } increment() { this.store.dispatch(increment()); } decrement() { this.store.dispatch(decrement()); } reset() { this.store.dispatch(reset()); } } 6、将MyCounter组件添加到您的AppComponent模板中。 // src/app/app.component.html &lt;app-my-counter&gt;&lt;/app-my-counter&gt; 单击递增，递减和重置按钮以更改计数器的状态。 让我们介绍一下您所做的事情： 定义的事件表达动作。 定义了一个reducer功能来管理计数器的状态。 注册了整个应用程序中可用的全局状态容器。 注入了存储服务以调度动作并选择计数器的当前状态。 通过actions、reducers和selectors了解NgRx应用程序的体系结构 Actios Actions是NgRx中的主要构建块之一。 Actions表示在整个应用程序中发生的独特事件。 从用户与页面的交互，通过网络请求的外部交互以及与设备API的直接交互，这些以及更多事件均通过actions进行了描述。 NgRx中的Action由一个简单的接口组成： // Action Interface interface Action { type: string; } 接口具有单个属性，即类型，表示为字符串。 type属性用于描述将在您的应用程序中分派的操作。 该类型的值以[Source] Event的形式出现，用于提供有关它是什么actions类别以及从哪里调度动作的上下文。 您向actions添加属性以为操作提供其他上下文或元数据。 让我们看一下启动登录请求的示例Action: // login-page.actions.ts import { createAction, props } from '@ngrx/store'; export const login = createAction( '[Login Page] Login', props&lt;{ username: string; password: string }&gt;() ); createAction函数返回一个函数，该函数在被调用时将以Action接口的形式返回一个对象。 props方法用于定义处理动作所需的任何其他元数据。 Action创建者提供了一种一致的，类型安全的方式来构造要分派的Action。 使用Action创建者在分派时返回Action。 // login-page.component.ts onSubmit(username: string, password: string) { store.dispatch(login({ username: username, password: password })); } login Action创建者将收到一个用户名和密码的对象，并返回一个普通的JavaScript对象，其类型属性为[Login Page] Login，并将用户名和密码作为附加属性。 返回的Action具有非常具体的上下文，关于操作来自何处以及发生了什么事件: 操作的类别捕获在方括号[]中,该类别用于对特定区域的操作进行分组，无论是组件页面，后端API还是浏览器API。 类别后的登录文本是有关此操作发生了什么事件的描述。在这种情况下，用户单击登录页面上的登录按钮以尝试使用用户名和密码进行身份验证。 Reducers NgRx中的reducer负责处理应用程序中从一个状态到下一个状态的转换。 Reducer纯函数通过根据操作的类型确定要处理的操作来处理这些转换。 由Reducer管理的每个状态都有一些一致的部分： 定义state形状的接口或类型 参数包括初始状态或当前状态以及当前操作 处理state更改的功能及其相关 以下是一组处理记分板state的操作示例以及相关的reducer功能: 首先，定义一些与state交互的action。 // scoreboard-page.actions.ts import { createAction, props } from '@ngrx/store'; export const homeScore = createAction('[Scoreboard Page] Home Score'); export const awayScore = createAction('[Scoreboard Page] Away Score'); export const resetScore = createAction('[Scoreboard Page] Score Reset'); export const setScores = createAction('[Scoreboard Page] Set Scores', props&lt;{game: Game}&gt;()); 接下来，创建一个reducer文件，该文件导入action并为state块定义形状。 1、定义state形状 每个reducer函数都是一个action监听器。上面定义的记分板action描述了reducer可能处理的过渡。导入多组操作以处理reducer中的其他状态转换。 // scoreboard.reducer.ts import { Action, createReducer, on } from '@ngrx/store'; import * as ScoreboardPageActions from '../actions/scoreboard-page.actions'; export interface State { home: number; away: number; } 2.设置初始state值 初始状态为状态提供一个初始值，如果当前状态未定义，则提供一个值。 您将默认状态设置为所需状态属性的初始状态。 创建并导出变量以捕获具有一个或多个默认值的初始状态。 // scoreboard.reducer.ts export const initialState: State = { home: 0, away: 0, }; 3.创建recucer函数 reducer功能的职责是以不变的方式处理状态转换。创建一个reducer函数，该函数处理使用createReducer函数管理计分板state的action。 const scoreboardReducer = createReducer( initialState, on(ScoreboardPageActions.homeScore, state =&gt; ({ ...state, home: state.home + 1 })), on(ScoreboardPageActions.awayScore, state =&gt; ({ ...state, away: state.away + 1 })), on(ScoreboardPageActions.resetScore, state =&gt; ({ home: 0, away: 0 })), on(ScoreboardPageActions.setScores, (state, { game }) =&gt; ({ home: game.home, away: game.away })) ); export function reducer(state: State | undefined, action: Action) { return scoreboardReducer(state, action); } 导出的reducer函数是必需的，因为AOT编译器不支持函数调用。 4、注册root state 应用程序的state被定义为一个大对象。注册reducer函数以管理部分state时，只会在对象中定义具有关联值的键。要在您的应用程序中注册全局store，请使用StoreModule.forRoot（）方法以及定义您的state的键/值对的映射。 StoreModule.forRoot（）注册应用程序的全局提供程序，包括您注入到组件和服务中的Store服务，以分派操作并选择状态 // app.module.ts import { NgModule } from '@angular/core'; import { StoreModule } from '@ngrx/store'; import * as fromScoreboard from './reducers/scoreboard.reducer'; @NgModule({ imports: [ StoreModule.forRoot({ game: fromScoreboard.reducer }) ], }) export class AppModule {} 使用StoreModule.forRoot（）注册state可确保在应用程序启动时定义state。通常，您注册的root state始终需要立即对应用程序的所有区域可用。 6.注册功能state 功能state的行为与root state相同，但是允许您在应用程序中使用特定功能区域定义它们。 您的root state是一个大对象，而功能state会在该对象中注册其他键和值。 让我们从一个空的state对象开始。 import { NgModule } from '@angular/core'; import { StoreModule } from '@ngrx/store'; @NgModule({ imports: [ StoreModule.forRoot({}) ], }) export class AppModule {} 这会将您的应用程序注册为root state为空的对象。 {} 现在，将记分板reducer与名为ScoreboardModule的NgModule功能一起使用，以注册其他state // scoreboard.reducer.ts export const scoreboardFeatureKey = 'game'; // scoreboard.module.ts import { NgModule } from '@angular/core'; import { StoreModule } from '@ngrx/store'; import * as fromScoreboard from './reducers/scoreboard.reducer'; @NgModule({ imports: [ StoreModule.forFeature(fromScoreboard.scoreboardFeatureKey, fromScoreboard.reducer) ], }) export class ScoreboardModule {} 将ScoreboardModule添加到AppModule以加载state。 // app.module.ts import { NgModule } from '@angular/core'; import { StoreModule } from '@ngrx/store'; import { ScoreboardModule } from './scoreboard/scoreboard.module'; @NgModule({ imports: [ StoreModule.forRoot({}), ScoreboardModule ], }) export class AppModule {} 一旦记分板模块被加载，game键就成为root state对象中的一个属性，并且现在处于state中进行管理 { game: { home: 0, away: 0 } } 立即加载state还是延迟加载state取决于应用程序的需求。您可以使用功能state随着时间推移并通过不同的功能模块来构建state对象。 Selectors Selectors是用于获取存储state切片的纯函数。 @ ngrx / store提供了一些帮助程序功能来优化此选择。选择state切片时，选择器提供许多功能: 可移植性 记忆化 组成 可测性 类型安全。 使用createSelector和createFeatureSelector函数时，@ ngrx / store会跟踪调用选择器函数的最新参数。 因为选择器是纯函数，所以当参数匹配时可以返回最后的结果，而无需重新调用选择器函数。 这可以提供性能优势，尤其是对于执行昂贵计算的选择器而言。 这种做法称为记忆。 对一个state使用选择器： import { createSelector } from '@ngrx/store'; export interface FeatureState { counter: number; } export interface AppState { feature: FeatureState; } export const selectFeature = (state: AppState) =&gt; state.feature; export const selectFeatureCount = createSelector( selectFeature, (state: FeatureState) =&gt; state.counter ); 对多个状态使用选择器: createSelector可用于基于同一状态的多个切片从状态中选择一些数据。 createSelector函数最多可以使用8个选择器函数，以进行更完整的状态选择。 例如，假设您在状态中有一个selectedUser对象。 您还具有book对象的allBooks数组。 您想显示当前用户的所有书籍。 您可以使用createSelector来实现。 即使您在allBooks中对其进行了更新，您的可见图书也将始终是最新的。 如果选择了一本，它们将始终显示属于您用户的图书，而当未选择任何用户时，它们将显示所有图书。 结果将只是状态的另一部分过滤掉您的某些状态。 而且它将永远是最新的。 import { createSelector } from '@ngrx/store'; export interface User { id: number; name: string; } export interface Book { id: number; userId: number; name: string; } export interface AppState { selectedUser: User; allBooks: Book[]; } export const selectUser = (state: AppState) =&gt; state.selectedUser; export const selectAllBooks = (state: AppState) =&gt; state.allBooks; export const selectVisibleBooks = createSelector( selectUser, selectAllBooks, (selectedUser: User, allBooks: Book[]) =&gt; { if (selectedUser &amp;&amp; allBooks) { return allBooks.filter((book: Book) =&gt; book.userId === selectedUser.id); } else { return allBooks; } } ); 将选择器与props一起使用: 要根据store中不可用的数据选择state，可以将props传递给选择器功能。 这些props通过每个选择器和投影仪功能传递。 为此，我们必须在组件内部使用选择器时指定这些props。 例如，如果我们有一个计数器，并且想将其值相乘，则可以将相乘因子添加为prop： 选择器或投影仪的最后一个参数是props参数，在我们的示例中，它看起来如下: export const getCount = createSelector( getCounterValue, (counter, props) =&gt; counter * props.multiply ); 在组件内部，我们可以定义props： ngOnInit() { this.counter = this.store.pipe(select(fromRoot.getCount, { multiply: 2 })) } 以下是使用以ID区分的多个计数器的示例。 export const getCount = () =&gt; createSelector( (state, props) =&gt; state.counter[props.id], (counter, props) =&gt; counter * props.multiply ); 组件的选择器现在正在调用工厂函数来创建不同的选择器实例： ngOnInit() { this.counter2 = this.store.pipe(select(fromRoot.getCount(), { id: 'counter2', multiply: 2 })); this.counter4 = this.store.pipe(select(fromRoot.getCount(), { id: 'counter4', multiply: 4 })); this.counter6 = this.store.pipe(select(fromRoot.getCount(), { id: 'counter6', multiply: 6 })); } ","link":"https://fanguyun214.github.io/post/ngrx-shi-yong/"},{"title":"Charles安装及代理配置","content":"Charles是一款用于HTTP信息抓包工具，可以快速有效的获得HTTP信息，非常利于开发者的网页开发和调试修改等。 1、安装 官网下载 菜单栏【Charles → help → Registered to】,输入账号和key激活使用授权码生成访问 https://www.charles.ren/ 2. Charles客户端配置 安装好Charles后，在菜单栏勾选【Proxy -&gt; macOS Proxy】，macOS系统HTTP/HTTPS代理将会被自动设置为本地代理，默认端口8888。 3、抓取HTTPS 在菜单栏选择 【Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate】，会自动导入 Charles Proxy CA 证书并打开 Keychain Access 双击新导入的证书弹出证书信息页面，将 Secure Sockets Layer(SSL) 设置为Always Trust（始终信任），关闭页面后弹出密码提示，输入密码更新系统信任设置 在菜单栏选择 【Proxy -&gt; SSL Proxy Settings】，在SSL Proxying选项卡中可以添加需要抓包的域名端口 4、移动端代理配置 MAC开启Charles，确保移动端和PC端处于同一局域网 Mac局域网地址可以在Charles中从菜单栏【Help -&gt; Local IP Address】获取 设置iOS HTTP代理，打开iOS设备对应WIFI设置，添加代理IP地址（Mac的局域网地址）和端口号（8888） 在i移动设备上访问数据链接，Charles 弹出 Access Control 确认对话框，选择Allow，可以开始抓取HTTP包。 4、移动端HTTPS代理 在菜单栏选择 【Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate on a Mobile Device or a Remote Browser】，弹出提示框。 根据上述提示，在移动端访问//chls.pro/ssl ，下载证书并提示安装，根据提示一步一步安装好 4.1、IOS设备 证书会被添加到【设置 -&gt; 通用 -&gt; 描述文件】中。 进入【设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置】，对上一步安装的Charles证书启用完全信任 在iOS设备上访问HTTPS数据链接，可以开始抓取HTTPS包 4.2、安卓设备 同上，浏览器打开下载证书地址 证书下载成功后，查看已下载的证书，选择证书安装，输入证书名称，证书命名可随意填写，确定后安装成功。 安卓不同设备安装会有所差异。 6、其他工具 Fiddler 请求转发 Fiddler Https证书安装 whistle：web 项目调试 ","link":"https://fanguyun214.github.io/post/charles-an-zhuang-ji-dai-li-pei-zhi/"},{"title":"前端跨平台调试","content":"如何调试移动端页面一直是比较头疼的事。与桌面浏览器不同，当H5页面嵌入到app后，无法很方便地按出F12来查看元素，或者断点调试js。另外，移动端设备差异化非常严重，iphone 6 到 iphone 11，android 更是不用多说。 移动端调试痛点 设备差异、环境差异、系统差异。PC端浏览器开发者工具，VS Debug。移动端，我的手机是好的，测试小姐姐说她的手机有bug。微信微博等第三方环境，怎么调试？ 常用调试方法 Charles/Fiddler 抓包工具，可以截取包括 https 在内的各种网络请求并方便的查看具体信息。通过配置 WIFI 代理，也可以拦截手机发出的请求，在一定程度上帮助 debug。软件付费，而且它定位不了 js 的报错，所以只能作为一个辅助工具。 Android + Chrome浏览器 第一步：打开 Android 手机 设置 &gt; 开发者选项 &gt; USB调试。 第二步：通过数据线连接你的电脑和 Android 手机，允许USB调试。 第三步：Android手机下载一个手机版的Chrome浏览器，并在手机上的 Chrome浏览器 中打开你需要调试的页面。 第四步：打开电脑上的 Chrome浏览器，输入chrome://inspect/#devices Mac+IOS+Safari 第一步：打开苹果手机 设置 &gt; Safari浏览器 &gt; 高级 &gt; Web检查器 第二步： 打开 Mac 上的 Safari浏览器 &gt; 偏好设置 &gt; 高级 &gt; 在菜单栏中显示“开发”菜单 第三步： 用数据线连接你的 Mac 电脑和苹果手机，并选择信任设备。然后在手机的 Safari浏览器 中打开你需要调试的页面，然后在电脑Safari中打开调试页面，菜单 &gt; 开发 &gt; 设备名。选择打开的页面。 vConsole 腾讯出品的 Web 调试面板。vConsole 会在你网页中加一个悬浮的小按钮，可以点击它来打开关闭调试面板，并查看 DOM、Console、Network和 本地存储 等信息。基本可以满足普通前端开发的需求。使用方法也很简单，通过npm安装或者直接在需要的页面引入 js文件 ，然后 new VConsole() 就可以了。 Eruda Eruda 是一个专为手机网页前端设计的调试面板，类似 DevTools 的迷你版，其主要功能包括：捕获 console 日志、检查元素状态、捕获XHR请求、显示本地存储和 Cookie 信息等等。 weiner weinre是一款很不错的网页检查工具，可以通过在本地启动一个 weinre 服务，并向手机网页嵌入一段 js 脚本来实现和电脑的通信，已达到类似浏览器开发工具那样的的调试效果，它的操作界面和 vConsole 差不多，主要包括查看 DOM、Console、Network 等，只不过这一切是在电脑上操作，而不是在手机上。 常见调试场景 本地开发host映射，如微信，微博授权，支付域名固定 独立H5页面真机调试 嵌入第三方调试 特定第三方环境调试 线上环境调试 调试工具推荐 whistle是基于Node实现的跨平台web调试代理工具，主要用于查看、修改HTTP、HTTPS、Websocket的请求/响应，也可以作为HTTP代理服务器使用，whistle采用的是类似配置系统hosts的方式，一切操作都可以通过配置实现，支持域名、路径、正则表达式、通配符、通配路径等多种匹配方式，且可以通过Node模块扩展功能。 官方文档：wproxy.org/whistle/ 安装使用 安装 npm install -g whistle 命令 w2 help Usage: whistle &lt;command&gt; [options] Commands: status Show the running status of whistle use/add [filepath] Set rules from a specified js file (.whistle.js by default) run Start a front service start Start a background service stop Stop current background service restart Restart current background service help Display help information 使用 // 启动 w2 start // 重启 w2 stop // 停止 w2 stop 设置代理 1、全局代理 2、浏览器代理 安装浏览器插件，如Chrome： SwitchyOmega 3、移动端设置代理 访问配置页面 方式1：域名访问 http://local.whistlejs.com/ 方式2：通过ip+端口来访问，形式如 http://whistleServerIP:whistlePort/ e.g. http://127.0.0.1:8899 方式2：通过命令行参数 -P xxxx 自定义webui的端口(xxxx表示要设置的端口号)，自定义端口支持上述两种方 式访问，也支持 http://127.0.0.1:xxxx 注入文件配置 w2 add [filepath] 常用功能 Host映射 # host映射 192.168.0.107 http://checkout.m.xiaodianpu.com 192.168.0.107 http://oauth2.m.xiaodianpu.com 192.168.0.107 http://shop12345678.m.xiaodianpu.com 127.0.0.1 http://shop.m.xiaodianpu.com # 直接的host配置 192.168.0.107:8081 one.test.com two.test.com # 对全部域名路径替换host 192.168.0.107 three.com/ads # 对特定的路径替换host 请求转发 # 请求转发 shop02604127.m.xiaodianpu.com https://shop02604127.m.xiaodianpu.com oauth2.m.xiaodianpu.com https://oauth2.m.xiaodianpu.com checkout.m.xiaodianpu.com https://checkout.m.xiaodianpu.com **.m.xiaodianpu.com https://shop02604127.m.xiaodianpu.com # 所有子域名转发生效 调试远程页面 https://shop02604127.m.xiaodianpu.com weinre://test 开启Eruda，插件形式注入 # 开启eruda shop12345678.m.xiaodianpu.com whistle.inspect://e checkout.m.xiaodianpu.com whistle.inspect://e 开启Vconsole, 插件形式注入 # 开启eruda shop12345678.m.xiaodianpu.com whistle.inspect://e checkout.m.xiaodianpu.com whistle.inspect://e 数据Mock 基于Mock.js http://mock.local/data.json vase://mock_json_demo 开启跨域 # 开启跨域 test.com file://{createData.json} 脚本注入 # 脚本注入 test.com html://Users/fan/xdp-webapp/whistle/debug.html shop02604127.m.xiaodianpu.com js://Users/fan/xdp-webapp/whistle/debug.js test.com css://Users/fan/xdp-webapp/whistle/debug.css 重定向 # 重定向 https://www.baidu.com/ redirect://https://m.xiaodianpu.com 替换线上文件 static.seecsee.com/ufs/webapp/3de34c68/main-es2015.ce5beedbe4b13d68c4ab.js file:///Users/fan/xdp-webapp/dist/apps/webapp/browser/main.js 修改请求 # 修改url参数 www.qq.com urlParams://E:\\test\\params.json # 请求方法 www.qq.com method://post # 添加请求头 www.qq.com reqHeaders://(x-a=1&amp;x-b=a%20b) # 修改referer(修改referer快捷方法) www.qq.com referer://http://ke.qq.com/ # 修改cookie(修改请求cookie快捷方法) www.qq.com reqCookie://{reqCookie.json} # 修改请求表单 www.qq.com params://{form.json} # 修改接口返回状态 https://test.com/test statusCode://500 修改响应 # 修改响应状态码 www.qq.com statusCode://500 # 请求不会发送到后台服务器，可以用来模拟4xx、5xx请求 www.qq.com replaceStatus://404 # 请求返回后再修改statusCode # 添加响应头 www.qq.com resHeaders://(x-res-a=1&amp;x-res-b=a%20b) # 修改响应类型(修改响应类型的快捷方法) www.qq.com resType://text/plain # 或者： www.qq.com resType://text # 请求替换 www.qq.com https://www.baidu.com # 本地替换(windows中目录分割符可以用`\\`，也可以用`/`) www.qq.com file://E:\\xxx # 等价于： file://E:/xxx www.qq.com # Mac或Linux www.qq.com file:///User/xxx/test # 如果要让本地没有对应文件的请求继续请求线上，可以采用 www.qq.com xfile://E:\\xxx # 本地替换jsonp www.qq.com tpl://E:\\xxx.json # xxx.json: {callback}({&quot;ec&quot;: 0}) www.qq.com xtpl://E:\\xxx.json # xxx.json: {callback}({&quot;ec&quot;: 0}) # 说明：会把内容 append 到请求后面 http://mydomain.com/style.css resAppend://{myAppend.css} # 说明：完全替换请求内容 http://mydomain.com/style.css resBody://{myResBody.css} 启用或禁用一些配置 # 拦截url里面有baidu的https请求 /baidu/ enable://intercept # 拦截域名www.google.com下的所有https请求，且不在Network上显示 www.google.com enable://intercept|hide # 禁用请求的缓存，只要经过代理且匹配到的请求都不会使用缓存 # 跟 cache 协议的区别是，cache 只是用来设置响应的缓存头 wwww.test.com disable://cache # 禁用请求和响应的cookie wwww.test.com disable://cookie # 也可以写成复数形式cookies # 只禁用请求的cookie wwww.test.com disable://reqCookie # 也可以写成复数形式reqCookies # 只禁用响应的cookie wwww.test.com disable://resCookie # 也可以写成复数形式reqCookies 更多 whistle更多使用及插件开发请参考官方文档：wproxy.org/whistle/ 项目中具体的问题，根据场景，选择合适的工具方法，搭配使用！ ","link":"https://fanguyun214.github.io/post/qian-duan-kua-ping-tai-diao-shi/"},{"title":"支付宝支付接入","content":"支付宝开放平台，致力于为开发者提供支付、理财、信用、口碑开店、安全、营销、社交等各类能力及行业解决方案。 1、支付宝应用接入流程 流程 说明 1、创建应用 应用介绍 创建应用 应用安全开发指南 设计规范 2、开始开发 了解产品 快速接入 更多帮助与支持 3、上线使用 上线应用 使用应用 签约功能 发布到服务市场 2、应用简介 通过创建应用的方式接入蚂蚁各项产品（如当面付、开店、发券、服务窗、余利宝等）接口并进行开发。 目前开放平台的应用按使用对象分为两类：自研型应用 和 第三方应用（商户服务型应用）: 应用类型 说明 自研型应用 使用开放的功能，为自己或自己公司开发应用。自研型应用分为网页/移动，小程序，生活号。 第三方应用 适用于服务商，为商户开发应用，拓展商户使用 如果您的应用为第三方应用（即供商家使用），则需要商家对该应用进行授权，详细步骤可以参考 第三方应用授权。 创建应用 -&gt; 应用配置 -&gt; 上线应用 -&gt; 签约功能（如手机网站支付，APP支付等）-&gt; 开发接入已签约功能 - 开发者使用支付宝账号登录开放平台（需实名认证的支付宝账号），根据实际需求创建应用（如“支付应用”）。 输入名称，上传应用图标，选择应用功能（如手机网站支付，APP支付等），下载签名工具生成生成商户应用私钥和商户应用公钥，回到开放平台的应用完善页面，点击设置应用公钥，接收验证码，输入上一步生成的商户应用公钥，点击确定。然后会生成对应的支付宝公钥，商户应用公钥和支付宝公钥要明确区分开。 开发代码中要使用到 支付宝公钥 和 商户应用私钥 提交审核，一天之后，审核完成，显示应用上线。签约选择的应用功能，开始代码开发。 3、手机网站支付接入(H5网站) - 3.1、业务场景 移动网页应用无需集成SDK也可以唤起支付宝客户端支付。 在网页应用中调用支付宝提供的网页支付接口，接口会调起支付宝客户端内的支付模块，此时会从商家网页应用跳转到支付宝客户端中并开始支付；支付完成后会跳转回商家网页应用内，最后商家展示支付结果。 - 3.2、接入条件 申请前必须拥有经过实名认证的支付宝账户； 企业或个体工商户可申请； 需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致； 网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息； 网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致； 如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。 费率按单笔计算；一般行业费率：0.6%； 特殊行业费率：1.2%，特殊行业范围包括：手机、通讯设备销售；家用电器；数码产品及配件；休闲游戏；网络游戏点卡、渠道代理；游戏系统商；网游周边服务、交易平台；网游运营商（含网页游戏） - 3.3 开发前准备&amp;快速接入 1、创建应用并获取APPID 登录蚂蚁金服开放平台（open.alipay.com），登记个人应用后，审核通过将会得到应用的唯一标识（APPID）。 2、配置密钥 开发者调用接口前需要先生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY）。 详情见：https://docs.open.alipay.com/291/105971/ 3、下载服务端SDK 下载地址：https://docs.open.alipay.com/203/105910/ 4、接口调用配置 5、调用接口 手机网站支付产品包含两类API： 页面跳转类：需要从前端页面以Form表单的形式发起请求，浏览器会自动跳转至支付宝的相关页面（一般是收银台或签约页面），用户在该页面完成相关业务操作后再回跳到商户指定页面。例如本产品中的手机网站支付接口alipay.trade.wap.pay。 系统调用类：直接从服务端发起HTTP请求，支付宝会同步返回请求结果。例如本产品中的交易查询等配套API。 接口调用流程 👋👋👋👋 - 3.4、手机网站支付产品包含的接口和描述如下： 接口名称 描述 alipay.trade.wap.pay 手机网页支付接口 通过此接口传入订单参数，同时唤起支付宝手机网页支付页面 alipay.trade.close 交易关闭接口 通过此接口关闭此前已创建的交易，关闭后，用户将无法继续付款。仅能关闭创建后未支付的交易。 alipay.trade.query 交易状态查询接口 通过此接口查询某笔交易的状态，交易状态：交易创建，等待买家付款；未付款交易超时关闭，或支付完成后全额退款；交易支付成功；交易结束，不可退款。 alipay.trade.refund 交易退款接口 通过此接口对单笔交易完成退款操作 alipay.trade.fastpay.refund.query 退款查询 查询退款订单的状态 alipay.data.dataservice.bill.downloadurl.query 账单查询接口 调用此接口获取账单的下载链接 手机网页支付接口详细API 4、如何使用沙箱环境做开发调试 沙箱环境是开放平台提供给开发者调试接口的环境，具体操作步骤见沙箱接入指南。 目前支付宝沙箱环境支持手机网站支付，并且在安装了沙箱支付宝钱包后，可以唤起沙箱支付宝钱包进行支付。 在没有应用或者应用还未上线及未签约支付功能时，可使用沙箱环境做开发联调，联调完成后，切换回商家应用APPid，商家私钥，商家公钥，支付宝公钥，做线上真实逻辑测试。 下载支付宝开放平台助手 -&gt; 生成RSA商家应用私钥、公钥 -&gt; 沙箱环境配置生成的应用公钥获取到支付宝公钥 -&gt; AliPAySdk配置秘钥 -&gt; 安装沙箱环境支付宝APP -&gt; 客户端网页调用支付接口 -&gt; 拉起沙箱环境支付宝APP -&gt; 完成支付 5、其他 支付宝开发者中心 手机网站支付文档 沙箱应用 服务端 SDK RSA 秘钥 支付接口 API 账户成员管理 支付宝开放平台开发助手 基于AliPaySDK的沙箱环境支付DEMO: Demo Repo: https://github.com/fanguyun214/alipay-node-demo 扫码体验（微信环境不能拉起支付宝）： ","link":"https://fanguyun214.github.io/post/zhi-fu-bao-zhi-fu-jie-ru/"},{"title":"HTTP客户端缓存","content":" HTTP缓存体系 策略 说明 缓存存储策略 这个策略的作用只有一个，用于决定 Http 响应内容是否可缓存到客户端 缓存过期策略 这个策略的作用也只有一个，那就是决定客户端是否可直接从本地缓存数据中加载数据并展示（否则就发请求到服务端获取） 缓存对比策略 将缓存在客户端的数据标识发往服务端，服务端通过标识来判断客户端 缓存数据是否仍有效，进而决定是否要重发数据。浏览器缓存控制机制有两种：HTML Meta标签 vs. HTTP头信息 HTTP缓存控制 HTML Meta标签控制缓存 浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）。但是也有非HTTP协议定义的缓存机制，如使用HTML Meta 标签，可以在HTML页面的节点中加入标签，代码如下： 用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式； 用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出； 只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。而广泛应用的还是 HTTP头信息 来控制缓存。 HTTP头信息控制缓存 浏览器第一次请求流程图： 浏览器再次请求 HTTP协议 http报文就是客户端（如浏览器）和web服务器通信时发送和响应的的数据。 http请求由三部分组成分别是：请求行、消息报头、请求正文 http响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 与缓存相关的信息，都包含在消息报头(header)中 与缓存有关的header Request： 参数 说明 Cache-Control: max-age=0 以秒为单位 If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。 If-None-Match: &quot;0693f67a67cc1:0&quot; 缓存文件的Etag值 Cache-Control: no-cache 不使用缓存 Pragma: no-cache 不使用缓存 Response: 参数 说明 Cache-Control: public 响应被缓存, 代理服务器可缓存 Cache-Control: private 响应被缓存, 只客户端缓存 Cache-Control:no-cache 提醒浏览器要从服务器提取文档进行验证 Cache-Control:no-store 绝对禁止缓存（用于机密，敏感文件） Cache-Control: max-age=60 60秒之后缓存过期（相对时间） Date: Mon, 19 Nov 2012 08:39:00 GMT 当前response发送的时间 Expires: Mon, 19 Nov 2012 08:40:01 GMT 缓存过期的时间（绝对时间） Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间 ETag: &quot;20b1add7ec1cd1:0&quot; 服务器端文件的Etag值 Expires Expires的值为web服务器返回的到期时间(GMT 格林威治时间),浏览器下次请求时间小于服务器返回的时间则浏览器直接从缓存中获取数据，而不用再次发送请求 Cache-Control Cache-Control常见的取值有private、public、no-cache、max-age，no-store private:客户端可以缓存 public :客户端和代理服务器都可缓存 max-age=:缓存存储的最大周期，超过这个时间缓存被认为过期（单位秒） no-cache:这个很容易让人产生误解，使人误以为是响应不被缓存，实际上Cache-Control:no-cache是会被缓存的，只不过每次在向浏览器提供响应数据时，浏览器每次都要向服务器发送请求，由服务器来决策来评估缓存的有效性。 no-store: 所有内容都不缓存（真真的不缓存） 更多详细的Cache-Control的取值参考MDN文档https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control 强制缓存:Expires和Cache-Control区别 Expires和Cache-control称为强制缓存，都是在缓存未失效时，浏览器不向服务端发起请求，直接从缓存中取数据。 Expires是上古时代Http1.0的东西了，现在默认浏览器均默认使用的是Http1.1了，所以它的作用是可以基本忽略。Expires有一个缺点，就是返回的时间的服务器的绝对时间，用本地时间和服务端时间比较是否过期，是不严谨的，用户是可以随便修改本地时间的，那这样缓存随时可以过期，所以被Cache-Control:max-age=取代了，在http1.1中Cache-Control优先级高于Expires。软件工程的特点是向下兼容，Expires一直就没有抛弃，对于使用http1.0协议的浏览器仍然有作用。 Last-Modified 服务器响应浏览器请求，告诉浏览器资源的最后修改时间 Etag 服务器响应请求时，告诉客户端（浏览器）当前请求的资源在服务器标识（Etag的生成算法由服务器决定，不同的web服务器生成etag的算法可能还不一样,Http协议并没有要求etag的生成规则，如文件小的时候可以使用md5sum sha1sum,或者根据文件修改时间，文件大小，文件inode文件属性综合生成，这里不做详细叙述），我们可以将其理解为一个资源的唯一标识，只要文件发生变化Etag的值也变化。 对比缓存:Last-Modified/If-Modified-Since和Etag/If-None-Match Last-Modified和Etag称为对比缓存，所谓对比缓存，顾明思议，就是需要服务器来比较判断，来告诉客户端（浏览器）是否可以使用本地缓存，对比缓存生效时，服务器返回给客户端（浏览器）的Http Code为304,服务器只是返回的http header信息，并无响应正文，客户端通过服务器返回的状态码304，知道本地缓存并无修改，可以直接使用本地缓存，这样大大的较少的客户端请求响应时间。 对比缓存大致流程是这样的，当浏览器请求服务器的某资源时, 服务器得到资源的最后修改时间(Last-Modified)或根据一定的算法生成资源的标识（Etag），并将Last-Modified或If-Modified-Since返回给浏览器，浏览器把Last-Modified或Etag 和 资源内容同时缓存在本地，当下次再次向服务器请求此资源时，会将If-Modified-Since: Mon, 07 Nov 2016 07:51:11 GMT 或If-None-Match: xxxxxxx&quot;的请求头把发送给服务器，服务器再次计算资源的Last-Modified或Etag,如果和客户端传来的值比较不相同，则表明资源发生了变化，则给浏览器返回Http Code 200。并将资源内容返回给浏览器，如果相同表示没有变化就给浏览器返回Http Code 304 ，并不需要返回资源内容给浏览器。 对于浏览器来说的话，一般会在强制缓存过期的情况下（或者按F5刷新,不同的浏览器可能不一样，firefox是按F5）如果资源原先的响应header中带有Last-Modified和Etag的话，浏览器请求时会在请求header中带上If-Modified-Since和If-None-Match。 Last-Modified和Etag区别 在这里，也许你可能会问，通过Last-Modified就可以知道资源内容是否发生了变化，为什么还需要Etag呢，这不是多此一举吗？，主要原因Etag解决了Last-modified没能解决的问题，Etag比Last-Modified更加严谨。 1.一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了 2.某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断 3.如需要对动态生成的内容做缓存，那就可以用etag来控制缓存了 需要注意的是，如果同时有Last-Modified和Etag存在，在发送请求时，浏览器会一次性的将这两个值都发给服务器，没有优先级，服务器是都比较，还是只比较一个，不同的web服务器可能比较逻辑不一样吧。 Http请求头中Cache-Control: no-cache的意义 一般按ctrl+f5强制刷新时，请求头里面都带有Cache-Control: no-cache，其实这是跳过本地的强制缓存和告诉服务器跳过对比缓存，也就是重新请求资源了。对于前端同学在通过GET请求后端API接口时，在ajax的请求头中统一带上Cache-Control: no-cache 缓存体系关系 几种状态码的区别 总结 对于强制缓存（200），服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行对比缓存策略。 对于对比缓存（也称304缓存），将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。 ","link":"https://fanguyun214.github.io/post/http-ke-hu-duan-huan-cun/"},{"title":"公众号&H5微信支付接入","content":"商户在微信公众平台或开放平台提交微信支付申请，微信支付工作人员审核资料无误后开通相应的微信支付权限。微信支付申请审核通过后，商户在申请资料填写的邮箱中收取到由微信支付小助手发送的邮件，此邮件包含开发时需要使用的支付账户信息。 支付账户说明 支付接入流程 支付场景 JSAPI（公众号支付） 商户已有H5网站，用户通过消息或扫描二维码在微信内打开网页时，可以调用微信支付完成下单购买的流程 只能从微信浏览器中发起 可用微信浏览器内置方法，不需要引入微信jssdk 官方文档 H5支付 H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时， 商户发起本服务呼起微信客户端进行支付。主要用于触屏版的手机浏览器请求微信支付的场景。可以方便的从外部浏览器唤起微信支付 支付配置：登录商户平台--&gt;产品中心--&gt;我的产品--&gt;支付产品→H5支付 用户从非微信浏览器进入发起支付，不能从微信客户端调起 要求商户已有H5商城网站，并且已经过ICP备案 官方文档 JSAPI支付（公众号支付） 步骤一：添加开发者，微信授权登录配置 添加开发者 公众号登录管理后台，启用开发者中心，在开发者工具——web 开发者工具页面，向开发者微信号发送绑定邀请： 微信授权登录 开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头，授权回调域名配置规范为全域名，比如需要网页授权的域名 为：www.qq.com，配置以后此域名下面的页面http://www.qq.com/music.html 、 http://www.qq.com/login.html 都可以进行OAuth2.0鉴权。但http://pay.qq.com 、 http://music.qq.com 、 http://qq.com无法进行OAuth2.0鉴权。回调域名最多添加两个，需上传指定文件至回调域名根目录： scope参数 说明 snsapi_base 静默授权，获取openid，直接进入业务页面，用户无感知 snsapi_userinfo 需要用户手动同意，获取用户基本信息，对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知 具体而言，网页授权流程分为四步： 1、引导用户进入授权页面同意授权，获取code，接口示例: https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 2、通过code换取网页授权access_token（与基础支持中的access_token不同） 3、如果需要，开发者可以刷新网页授权access_token，避免过期 4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制） 前端授权获取code后通过code调用后端接口获取用户信息，需要提供AppId，AppSecret 微信官方文档 步骤二：设置支付域名与支付回调目录。 在微信商户平台（pay.weixin.qq.com）设置您的JSAPI支付支付目录，设置路径：商户平台--&gt;产品中心→开发配置，JSAPI支付在请求支付的时候会校验请求来源是否有在商户平台做了配置，所以必须确保支付目录已经正确的被配置，否则将验证失败，请求支付不成功。 支付目录配置 请求目录与设置目录必须一致，否则验证失败，支付不成功。 步骤三：微信内调用支付可用微信浏览器内置方法（不需要引入微信jssdk）： if (typeof WeixinJSBridge === 'undefined') { if (document.addEventListener) { document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false); } else if (document.attachEvent) { document.attachEvent('WeixinJSBridgeReady', onBridgeReady); document.attachEvent('onWeixinJSBridgeReady', onBridgeReady); } } else { WeixinJSBridge.invoke( 'getBrandWCPayRequest', { appId: newLevelOrder.appId, timeStamp: newLevelOrder.timeStamp, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: newLevelOrder.nonceStr, // 支付签名随机串，不长于 32 位 package: `prepay_id=${newLevelOrder.prePayId}`, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: 'MD5', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: newLevelOrder.paySign, // 支付签名 }, function(res: any) { if (res.err_msg === 'get_brand_wcpay_request:ok') { // 使用以上方式判断前端返回,微信团队郑重提示： //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。 // Toast.info('支付成功', 1, () =&gt; {}); router.push('/package-buy/pay-success'); } else if (res.err_msg === 'get_brand_wcpay_request:cancel') { Toast.info('取消支付', 1); } else if (res.err_msg === 'get_brand_wcpay_request:fail') { // Toast.info('支付失败', 1); router.push( `/package-buy/pay-fail?name=${query.name}&amp;price=${query.h5Price}&amp;packid=${query.id}&amp;type=${query.type}`, ); } }, ); } 网页端接口请求参数列表（参数需要重新进行签名计算，参与签名的参数为：appId、timeStamp、nonceStr、package、signType，参数区分大小写与顺序。） 调起支付请求参数由后端server调用统一下单接口返回，需提供AppId等。 微信支付接口签名校验工具，此工具旨在帮助开发者检测调用【微信支付接口API】时发送的请求参数中生成的签名是否正确。 本地开发使用开发者工具，可用https://ngrok.com/做内网穿透，实现本地授权回调，支付调起需真机环境 微信平台与名词说明 H5支付接入 微信平台申请：登录微信商户平台--&gt;产品中心--&gt;我的产品--&gt;支付产品--&gt; H5支付 申请流程：选择 H5支付--&gt;填写 H5 支付产品设置 1）写入对应的支付域名（最多可添加5个），域名必须通过 ICP 备案；当域名备案主体与公司名称不一致，需要上传授权函（设置页面不支持直接上传）；上传方式：账户中心--&gt;企业账号--&gt;公司网站，输入网址，上传授权函（审核3-7个工作日） 2）填写售卖场景/使用产品 3）输入产品对应网站域名 点击提交申请，页面提示审核时间为3-5个工作日（审核结果会反馈在消息中心） 流程： 1、用户在商户侧完成下单，使用微信支付进行支付 2、由商户后台向微信支付发起下单请求（调用统一下单接口）注：交易类型trade_type=MWEB 3、统一下单接口返回支付相关参数给商户后台，如支付跳转url（参数名“mweb_url”），商户通过mweb_url调起微信支付中间页 4、中间页进行H5权限的校验，安全性检查（此处常见错误请见下文） 5、如支付成功，商户后台会接收到微信侧的异步通知 6、用户在微信支付收银台完成支付或取消支付,返回商户页面（默认为返回支付发起页面） 7、商户在展示页面，引导用户主动发起支付结果的查询 8,9、商户后台判断是否接到收微信侧的支付结果通知，如没有，后台调用我们的订单查询接口确认订单状态 10、展示最终的订单支付结果给用户 使用JS-SDK实现公众号支付 步骤一： 在公众号后台配置相关参数“网页授权域名”、“JS接口安全域名”，在商户后台配置“支付授权目录”。 参数名称 配置地址 意义 可配置个数 网页授权域名 公众号后台-公众号设置-功能设置 在获取code的接口中配置的redirect_uri必须在这个域名下 2个 JS接口安全域名 公众号后台-公众号设置-功能设置 调用微信开放的JS接口的页面必须在此域名下 3个 支付授权目录 产品中心-开发配置-支付授权目录 调起微信支付的页面所在的目录 5个 步骤二：在需要调用JS接口的页面引入JS-SDK: 。 步骤三：通过config接口注入权限验证配置。 所有需要使用JS-SDK的页面必须先注入配置信息，否则将无法调用（同一个url仅需调用一次，对于变化url的SPA的web app可在每次url变化时进行调用，目前Android微信客户端不支持pushState的H5新特性，所以使用pushState来实现web app的页面会导致签名失败，此问题会在Android6.2中修复）。 wx.config({ debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: '', // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: '', // 必填，生成签名的随机串 signature: '',// 必填，签名 jsApiList: [] // 必填，需要使用的JS接口列表 }); 步骤四：通过ready接口处理成功验证、通过error接口处理失败验证。 wx.ready(function () { wx.checkJsApi({ jsApiList: ['chooseWXPay'], // 需要检测的JS接口列表，所有JS接口列表见附录2, success: function () { // 以键值对的形式返回，可用的api值true，不可用为false // 如：{&quot;checkResult&quot;:{&quot;chooseImage&quot;:true},&quot;errMsg&quot;:&quot;checkJsApi:ok&quot;} } }); }); config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。 wx.error(function(res){ // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开 config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。 }); 步骤五：发起一个微信支付请求。 wx.chooseWXPay({ timestamp: 0, // 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符 nonceStr: '', // 支付签名随机串，不长于 32 位 package: '', // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*） signType: '', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5' paySign: '', // 支付签名 success: function (res) { // 支付成功后的回调函数 } }); 参数通过统一下单接口拿到，paySign 采用统一的微信支付 Sign 签名生成方法，注意这里 appId 也要参与签名，appId 与 config 中传入的 appId 一致，即最后参与签名的参数有appId, timeStamp, nonceStr, package, signType。 JS-SDK使用文档 ","link":"https://fanguyun214.github.io/post/gong-zhong-hao-andh5-wei-xin-zhi-fu-jie-ru/"},{"title":"Superset新增图表类型","content":"前端(版本0.28) 1.新增图表文件 目录： superset/assets/src/visualizations 如新增EchartRader目录（后面目录和KEY值保持统一） images下提供一张正方形示例图 2.配置查询项 目录：superset/assets/src/explore/controlPanels 新增echartrader.js配置文件 import { t } from '@superset-ui/translation'; export default { label: t('echarts_radar'), showOnExplore: true, controlPanelSections: [{ label: t('Query'), expanded: true, //主要是下面的部分，可以找superset原有的图表模板，通过查看sql的方式看看每个配件都是做什么的 controlSetRows: [ ['metrics'], ['columns'], ['adhoc_filters'], ] }] } 在index.js中引入新增文件并关联 3.注册新增图表项 目录 superset/assets/src/visualizations/presets 编辑LegacyChartPreset.js,映入图表并注册 import EchartRader from '../EchartRader/EchartRaderPlugin'; export default class LegacyChartPreset extends Preset { constructor() { super({ name: 'Legacy charts', presets: [ new CommonChartPreset(), new DeckGLChartPreset(), new HierarchyChartPreset(), new MapChartPreset(), ], plugins: [ new BulletChartPlugin().configure({ key: 'bullet' }), new CalendarChartPlugin().configure({ key: 'cal_heatmap' }), new ChordChartPlugin().configure({ key: 'chord' }), new CompareChartPlugin().configure({ key: 'compare' }), new DualLineChartPlugin().configure({ key: 'dual_line' }), new EventFlowChartPlugin().configure({ key: 'event_flow' }), new ForceDirectedChartPlugin().configure({ key: 'directed_force' }), new HeatmapChartPlugin().configure({ key: 'heatmap' }), new HorizonChartPlugin().configure({ key: 'horizon' }), new LineMultiChartPlugin().configure({ key: 'line_multi' }), new PairedTTestChartPlugin().configure({ key: 'paired_ttest' }), new ParallelCoordinatesChartPlugin().configure({ key: 'para' }), new RoseChartPlugin().configure({ key: 'rose' }), new SankeyChartPlugin().configure({ key: 'sankey' }), new TimePivotChartPlugin().configure({ key: 'time_pivot' }), new EchartRader().configure({ key: 'echart_rader' }), ], }); } } 后端 新增处理数据接口 目录 /Users/fan/incubator-superset/superset/viz.py class echartsRadar(BaseViz): &quot;&quot;&quot; echarts radar viz &quot;&quot;&quot; viz_type = 'echart_rader' # 对应前端名字 verbose_name = _('echart_rader') is_timeseries = False def get_data(self, df): data = self.handle_js_int_overflow( dict( records=df.to_dict(orient='records'), columns=list(df.columns), )) columns_pre = [data['records'][i][data['columns'][0]] for i in range(len(data['records']))] max_num = np.max([data['records'][i][data['columns'][1]] for i in range(len(data['records']))]) columns = [{'name': columns_pre[i], 'max':str(max_num)}for i in range(len(columns_pre))] out_data = [ {'value': [data['records'][i][data['columns'][j+1]] for i in range(len(data['records']))], 'name':data['columns'][j+1]}for j in range(len(data['columns'])-1) ] return [{'indicator' : columns, 'data' : out_data}] ","link":"https://fanguyun214.github.io/post/superset-xin-zeng-tu-biao-lei-xing/"},{"title":"MongoDB笔记-3（Linux平台安装）","content":"下载 MongoDB提供了linux平台上32位和64位的安装包，你可以在官网下载安装包。 下载地址：http://www.mongodb.org/downloads 安装 下载完成后，解压压缩包 创建数据库目录 MongoDB的数据存储在data目录的db目录下，但是这个目录在安装过程不会自动创建，所以你需要手动创建data目录，并在data目录中创建db目录。 以下实例中我们将data目录创建于根目录下(/)。 注意：/data/db 是 MongoDB 默认的启动的数据库路径(--dbpath)。 mkdir -p /data/db 命令行中运行MongoDB服务 你可以再命令行中执行mongo安装目录中的bin目录执行mongod命令来启动mongdb服务 注意：如果你的数据库目录不是/data/db，可以通过 --dbpath 来指定。 # dapath用全路径 $ ./mongod --dbpath=xxx MongoDB后台管理 Shell 如果你需要进入MongoDB后台管理，你需要先打开mongodb装目录的下的bin目录，然后执行mongo命令文件。 MongoDB Shell是MongoDB自带的交互式Javascript shell,用来对MongoDB进行操作和管理的交互式环境。 当你进入mongoDB后台后，它默认会链接到 test 文档（数据库）： $ cd mongodb/bin $ ./mongo …… 由于它是一个JavaScript shell，您可以运行一些简单的算术运算: &gt; 2+2 4 &gt; 3+6 9 我们插入一些简单的数据，并对插入的数据进行检索： &gt; db.user.insert({x:10}) WriteResult({ &quot;nInserted&quot; : 1 }) &gt; db.user.find() { &quot;_id&quot; : ObjectId(&quot;5604ff74a274a611b0c990aa&quot;), &quot;x&quot; : 10 } &gt; 第一个命令将数据10插入到user集合的x字段中。 ","link":"https://fanguyun214.github.io/post/mongodb-bi-ji-3linux-ping-tai-an-zhuang/"},{"title":"MongoDB笔记-2（NoSQL）","content":"NoSQL(NoSQL = Not Only SQL )，意即&quot;不仅仅是SQL&quot;。 NoSQL 简介 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。 2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。 2009年在亚特兰大举行的&quot;no:sql(east)&quot;讨论会是一个里程碑，其口号是&quot;select fun, profit from real_world where relational=false;&quot;。因此，对NoSQL最普遍的解释是&quot;非关联型的&quot;，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 在现代的计算系统上每天网络上都会产生庞大的数据量。 这些数据有很大一部分是由关系数据库管理系统（RDMBSs）来处理。 1970年 E.F.Codd's提出的关系模型的论文 &quot;A relational model of data for large shared data banks&quot;，这使得数据建模和应用程序编程更加简单。 通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。 NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 关系型数据库遵循ACID规则 事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性： 1、A (Atomicity) 原子性 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 2、C (Consistency) 一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。 3、I (Isolation) 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 4、D (Durability) 持久性 持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 分布式系统 分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。 分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。 因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。 分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。 分布式计算的优点 可靠性（容错） ： 分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。 可扩展性： 在分布式计算系统可以根据需要增加更多的机器。 资源共享： 共享数据是必不可少的应用，如银行，预订系统。 灵活性： 由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。 更快的速度： 分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。 开放系统： 由于它是开放的系统，本地或者远程都可以访问到该服务。 更高的性能： 相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。 分布式计算的缺点 故障排除： ： 故障排除和诊断问题。 软件： 更少的软件支持是分布式计算系统的主要缺点。 网络： 网络基础设施的问题，包括：传输问题，高负载，信息丢失等。 安全性： 开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。 ","link":"https://fanguyun214.github.io/post/mongodb-bi-ji-2nosql/"},{"title":"MongoDB笔记-1（简介）","content":"MongoDB 是一个基于分布式文件存储的数据库，旨在为WEB应用提供可扩展的高性能数据存储解决方案。 MongoDB简介 是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。 MongoDB特点 高性能、易部署、易使用，存储数据非常方便。主要功能特性有： *面向集合存储，易存储对象类型的数据。 *模式自由。 *支持动态查询。 *支持完全索引，包含内部对象。 *支持查询。 *支持复制和故障恢复。 *使用高效的二进制数据存储，包括大型对象（如视频等）。 *自动处理碎片，以支持云计算层次的扩展性 *支持RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。 *文件存储格式为BSON（一种JSON的扩展）。 *可通过网络访问 MongoDB原理 所谓“面向集合”（Collection-Oriented），意思是数据被分组存储在数据集中，被称为一个集合（Collection)。每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档。集合的概念类似关系型数据库（RDBMS）里的表（table），不同的是它不需要定义任何模式（schema)。Nytro MegaRAID技术中的闪存高速缓存算法，能够快速识别数据库内大数据集中的热数据，提供一致的性能改进。模式自由（schema-free)，意味着对于存储在mongodb数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。存储在集合中的文档，被存储为键-值对的形式。键用于唯一标识一个文档，为字符串类型，而值则可以是各种复杂的文件类型。我们称这种存储形式为BSON（Binary Serialized Document Format） MongoDB适用场景 MongoDB 的主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS 系统（具有丰富的功能）之间架起 Mongo 适用于以下场景: ● 网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性。 ● 缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层。在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载。 ● 大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵，在此之前，很多时候程序员往往会选择传统的文件进行存储。 ● 高伸缩性的场景：Mongo 非常适合由数十或数百台服务器组成的数据库，Mongo 的路线图中已经包含对MapReduce 引擎的内置支持。 ● 用于对象及JSON 数据的存储：Mongo 的BSON 数据格式非常适合文档化格式的存储及查询。 MongoDB 的使用也会有一些限制，例如，它不适合于以下几个地方。 ● 高度事务性的系统：例如，银行或会计系统。传统的关系型数据库目前还是更适用于需要大量原子性复杂事务的应用程序。 ● 传统的商业智能应用：针对特定问题的BI 数据库会产生高度优化的查询方式。对于此类应用，数据仓库可能是更合适的选择。 ● 需要SQL 的问题。 Mongo不适用的场景如下： 要求高度事务性的系统。 传统的商业智能应用。 复杂的跨文档（表）级联查询。 MongoDB应用案例 Craiglist上使用MongoDB的存档数十亿条记录。 FourSquare，基于位置的社交网站，在Amazon EC2的服务器上使用MongoDB分享数据。 Shutterfly，以互联网为基础的社会和个人出版服务，使用MongoDB的各种持久性数据存储的要求。 bit.ly, 一个基于Web的网址缩短服务，使用MongoDB的存储自己的数据。 spike.com，一个MTV网络的联营公司， spike.com使用MongoDB的。 Intuit公司，一个为小企业和个人的软件和服务提供商，为小型企业使用MongoDB的跟踪用户的数据。 sourceforge.net，资源网站查找，创建和发布开源软件免费，使用MongoDB的后端存储。 etsy.com ，一个购买和出售手工制作物品网站，使用MongoDB。 纽约时报，领先的在线新闻门户网站之一，使用MongoDB。 CERN，著名的粒子物理研究所，欧洲核子研究中心大型强子对撞机的数据使用MongoDB。 ","link":"https://fanguyun214.github.io/post/mongodb-bi-ji-1jian-jie/"},{"title":"Nx:构建企业级Monorepo应用程序的新方法","content":"现代Web开发工具。 使用Nx，您可以： 使用Cypress，Jest，Prettier，TypeScript等现代工具...... 使用Angular和Node.js构建全栈应用程序 使用Google，Facebook和Microsoft开创的有效开发实践 TLDR npx create-nx-workspace myapp --preset=angular cd myapp ng serve myapp 创建Nx工作区 运用 npx npx create-nx-workspace@latest myworkspace 运用npm init npm init nx-workspace myworkspace 运用yarn create yarn create nx-workspace myworkspace 添加到现有Angular CLI工作区 如果您已经有一个常规的Angular CLI项目，则可以通过运行以下命令来添加Nx： ng add @nrwl/workspace 添加功能 如果您尚未指定任何预设，您将获得一个空的Nx工作区。没有用于构建，服务和测试的应用程序。您可以运行以下命令向工作区添加功能： 运用 npm npm install --dev @nrwl/angular # Adds Angular capabilities npm install --dev @nrwl/web # Adds Web capabilities npm install --dev @nrwl/react # Adds React capabilities npm install --dev @nrwl/node # Adds Node capabilities npm install --dev @nrwl/express # Adds Express capabilities npm install --dev @nrwl/nest # Adds Nest capabilities 运用yarn yarn add --dev @nrwl/react # Adds React capabilities yarn add --dev @nrwl/web # Adds Web capabilities yarn add --dev @nrwl/angular # Adds Angular capabilities yarn add --dev @nrwl/node # Adds Node capabilities yarn add --dev @nrwl/express # Adds Express capabilities yarn add --dev @nrwl/nest # Adds Nest capabilities 运用ng add ng add @nrwl/angular # Adds Angular capabilities ng add @nrwl/web # Adds Web capabilities ng add @nrwl/react # Adds React capabilities ng add @nrwl/node # Adds Node capabilities ng add @nrwl/express # Adds Express capabilities ng add @nrwl/nest # Adds Nest capabilities 创建第一个应用程序 添加功能后，您现在可以通过以下方式创建第一个应用程序 ng g @nrwl/angular:application myapp 结果将如下所示： &lt;workspace name&gt;/ ├── apps/ │ ├── myapp/ │ │ ├── src/ │ │ │ ├── app/ │ │ │ ├── assets/ │ │ │ ├── environments/ │ │ │ ├── favicon.ico │ │ │ ├── index.html │ │ │ ├── main.ts │ │ │ ├── polyfills.ts │ │ │ ├── styles.scss │ │ │ └── test.ts │ │ ├── browserslist │ │ ├── jest.config.js │ │ ├── tsconfig.app.json │ │ ├── tsconfig.json │ │ ├── tsconfig.spec.json │ │ └── tslint.json │ └── myapp-e2e/ │ ├── src/ │ │ ├── fixtures/ │ │ │ └── example.json │ │ ├── integration/ │ │ │ └── app.spec.ts │ │ ├── plugins/ │ │ │ └── index.ts │ │ └── support/ │ │ ├── app.po.ts │ │ ├── commands.ts │ │ └── index.ts │ ├── cypress.json │ ├── tsconfig.e2e.json │ ├── tsconfig.json │ └── tslint.json ├── libs/ ├── tools/ ├── README.md ├── angular.json ├── nx.json ├── package.json ├── tsconfig.json └── tslint.json Angular CLI在新项目中拥有的所有文件仍然在这里，只是在不同的文件夹结构中，这使得将来更容易创建更多的应用程序和库。 运行应用 ng serve myapp 构建多应用工作区 使用Angular和Nest构建一个完整的堆栈应用程序。 在前端和后端之间共享代码 创建一个空工作区 npx create-nx-workspace@latest myorg cd myorg 创建前端应用程序 使用Angular创建一个前端应用程序 ng add @nrwl/angular # Add Angular Capabilities to the workspace ng g @nrwl/angular:application frontend # Create an Angular Application 这将创建以下内容: myorg/ ├── apps/ │ ├── frontend/ │ │ ├── src/ │ │ │ ├── app/ │ │ │ │ ├── app.component.html │ │ │ │ ├── app.component.scss │ │ │ │ ├── app.component.spec.ts │ │ │ │ ├── app.component.ts │ │ │ │ ├── app.module.ts │ │ │ ├── assets/ │ │ │ ├── environments/ │ │ │ ├── favicon.ico │ │ │ ├── index.html │ │ │ ├── main.ts │ │ │ ├── polyfills.ts │ │ │ ├── styles.scss │ │ │ └── test.ts │ │ ├── browserslist │ │ ├── jest.config.js │ │ ├── tsconfig.app.json │ │ ├── tsconfig.json │ │ ├── tsconfig.spec.json │ │ └── tslint.json │ └── frontend-e2e/ ├── README.md ├── libs/ ├── tools/ ├── angular.json ├── nx.json ├── package.json ├── tsconfig.json └── tslint.json 运行： ng serve frontend 为应用程序服务 ng build frontend 构建应用程序 ng test frontend 测试应用程序 创建API应用并在前端引入API 添加HttpClientModule到apps/frontend/src/app/app.module.ts： import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, HttpClientModule], providers: [], bootstrap: [AppComponent] }) export class AppModule {} 编辑apps/frontend/src/app/app.component.ts以从Todos API获取Todos： import { Component } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs'; interface Todo { title: string; } @Component({ selector: 'myorg-root', template: ` &lt;h1&gt;Todos&lt;/h1&gt; &lt;ul&gt; &lt;li *ngFor=&quot;let t of (todos | async)&quot;&gt;{{ t.title }}&lt;/li&gt; &lt;/ul&gt; ` }) export class AppComponent { todos: Observable&lt;Todo[]&gt;; constructor(http: HttpClient) { this.todos = http.get&lt;Todo[]&gt;('/api/todos'); } } 由于API不存在，因此尚未显示任何待办事项。所以下一步是使用Nest创建api。 创建一个类似于之前创建Angular应用程序的Nest应用程序： ng add @nrwl/nest # Add Node Capabilities to the workspace ng g @nrwl/nest:application api --frontend-project frontend # sets up the proxy configuration so you can access the API in development 这将创建以下内容: myorg/ ├── apps/ │ ├── frontend/ │ ├── frontend-e2e/ │ └── api/ │ ├── src/ │ │ ├── app/ │ │ │ ├── app.controller.spec.ts │ │ │ ├── app.controller.ts │ │ │ ├── app.module.ts │ │ │ ├── app.service.spec.ts │ │ │ ├── app.service.ts │ │ ├── assets/ │ │ ├── environments/ │ │ └── main.ts │ ├── jest.config.js │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── libs/ ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json apps目录是Nx放置运行应用的地方：前端应用程序，后端应用程序，e2e测试套件等。 Nest是一个很棒的框架，它与Angular分享了许多核心概念。它使用模块，提供程序，依赖注入等。因此，大多数Angular开发人员发现Nest易于使用。 运行API应用 ng serve api 为应用程序服务 ng build api 构建应用程序 ng test api 测试应用程序 生成的apps/api/src/app/app.module.ts内容如下所示： import { Module } from '@nestjs/common'; import { AppController } from './app.controller'; import { AppService } from './app.service'; @Module({ imports: [], controllers: [AppController], providers: [AppService] }) export class AppModule {} 如果您愿意express，请改为运行以下命令： ng add @nrwl/express # Add Express Capabilities to the workspace ng g @nrwl/express:application api --frontend-project frontend 添加API接口 现在，通过更新添加接口以获取待办事项 app.service.ts import { Injectable } from '@nestjs/common'; export interface Todo { title: string; } @Injectable() export class AppService { getTodos(): Todo[] { return [{ title: 'Fix my computer!' }, { title: 'Fix my desk' }]; } } 和 app.controller.ts import { Controller, Get } from '@nestjs/common'; import { AppService, Todo } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get('todos') getTodos(): Todo[] { return this.appService.getTodos(); } } 现在，运行ng serve &amp; ng serve api并打开http：// localhost：4200以查看前端和后端是否正常工作: 有一个小问题。该Todo接口被定义了两次：一次是在前端，一旦在后端。这种重复将不可避免地导致两个接口不同步，这意味着运行时错误将会蔓延。最好共享此接口。 在前端和后端之间共享代码 在Nx中，代码通过创建库来共享。因为所有内容都在一个存储库中，所以可以导入库而无需将它们发布到注册表。 通过以下方式创建新库： ng g @nrwl/workspace:library data # This generates a barebone library with only Typescript setup &lt;workspace name&gt;/ ├── apps/ │ ├── frontend/ │ ├── frontend-e2e/ │ └── api/ ├── libs/ │ └── data/ │ ├── src/ │ │ ├── lib/ │ │ │ └── data.ts │ │ └── index.ts │ ├── jest.config.js │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json 接下来，Todo进入libs/data/src/lib/data.ts： export interface Todo { title: string; } 最后，更新前端和后端以从库中导入接口。 更新apps/frontend/src/app/app.component.ts： import { Observable } from 'rxjs'; import { Component } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Todo } from '@myorg/data'; @Component({ selector: 'myorg-root', template: ` &lt;h1&gt;Todos&lt;/h1&gt; &lt;ul&gt; &lt;li *ngFor=&quot;let t of (todos | async)&quot;&gt;{{ t.title }}&lt;/li&gt; &lt;/ul&gt; ` }) export class AppComponent { todos: Observable&lt;Todo[]&gt;; constructor(http: HttpClient) { this.todos = http.get&lt;Todo[]&gt;('/api/todos'); } } 更新apps/api/src/app/app.service.ts： import { Injectable } from '@nestjs/common'; import { Todo } from '@myorg/data'; @Injectable() export class AppService { getTodos(): Todo[] { return [{ title: 'Fix my computer!' }, { title: 'Fix my desk' }]; } } 更新apps/api/src/app/app.controller.ts： import { Controller, Get } from '@nestjs/common'; import { Todo } from '@myorg/data'; import { AppService } from './app.service'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get('todos') getTodos(): Todo[] { return this.appService.getTodos(); } } 在这个重构之后，后端和前端将共享相同的定义。能够将代码分解为许多具有定义良好的公共API的小型库，然后可以在后端和前端使用，这是Nx的一个关键特性。 应用依赖关系 拥有前端代码和后端代码已经令人惊叹了。只需几分钟，您就拥有了一个可以构建多个前端和后端应用程序并在它们之间共享代码的存储库。 但Nx可以做的远不止这些。在Nx中，您的库，后端应用程序，前端应用程序都是相同依赖关系图的一部分，您可以通过以下方式查看： npm run dep-graph 创建Libs Libs不仅仅是在Nx中共享代码的一种方式。它们也可用于将代码分解为具有定义良好的公共API的小单元。 公共API 每个Libs都有一个index.ts文件，用于定义其公共API。其他应用程序和库应该只访问index.ts导出的内容。图书馆的其他所有内容都是私密的 UI Libs 为了说明库的有用性，可以创建一个Angular ui库: ng g @nrwl/angular:lib ui 你应该看到以下内容： myorg/ ├── apps/ │ ├── todos/ │ ├── todos-e2e/ │ └── api/ ├── libs/ │ ├── data/ │ └── ui/ │ ├── src/ │ │ ├── lib/ │ │ │ ├── ui.module.spec.ts │ │ │ └── ui.module.ts │ │ └── index.ts │ ├── jest.conf.js │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json 该libs/ui/src/lib/ui.module.ts文件如下所示： import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; @NgModule({ imports: [CommonModule] }) export class UiModule {} 添加组件 通过运行以下命令将组件添加到新创建的ui库: ng g component todos --project=ui --export myorg/ ├── apps/ │ ├── todos/ │ ├── todos-e2e/ │ └── api/ ├── libs/ │ ├── data/ │ └── ui/ │ ├── src/ │ │ ├── lib/ │ │ │ ├── todos/ │ │ │ │ ├── todos.component.css │ │ │ │ ├── todos.component.html │ │ │ │ ├── todos.component.spec.ts │ │ │ │ └── todos.component.ts │ │ │ ├── ui.module.spec.ts │ │ │ └── ui.module.ts │ │ └── index.ts │ ├── jest.conf.js │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json 添加todos输入libs/src/lib/todos/todos.component.ts: import { Component, OnInit, Input } from '@angular/core'; import { Todo } from '@myorg/data'; @Component({ selector: 'myorg-todos', templateUrl: './todos.component.html', styleUrls: ['./todos.component.css'] }) export class TodosComponent implements OnInit { @Input() todos: Todo[]; constructor() {} ngOnInit() {} } 并更新todos.component.html以显示给定的待办事项： &lt;ul&gt; &lt;li *ngFor=&quot;let t of todos&quot;&gt;{{ t.title }}&lt;/li&gt; &lt;/ul&gt; 使用UI库，app挂载lib 现在导入UiModule到apps/todos/src/app/app.module.ts： import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import { HttpClientModule } from '@angular/common/http'; import { UiModule } from '@myorg/ui'; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, HttpClientModule, UiModule], providers: [], bootstrap: [AppComponent] }) export class AppModule {} 更新app.component.html： &lt;h1&gt;Todos&lt;/h1&gt; &lt;myorg-todos [todos]=&quot;todos&quot;&gt;&lt;/myorg-todos&gt; &lt;button (click)=&quot;addTodo()&quot;&gt;Add Todo&lt;/button&gt; app和Libs 根据项目复杂度可将架构拆分为多个app，对应的app可以挂载对应的lib。 app配置依赖注入和连接Libs。它们不应包含任何组件，服务或业务逻辑。 Libs包含服务，组件，实用程序等。它们具有定义良好的公共API。 典型的Nx工作区比app具有更多的Libs，因此要特别注意libs目录的组织。 将特定于app的libs放入与app名称匹配的目录中是一个很好的约定： happynrwl/ ├── apps/ │ ├── happynrwlapp/ │ ├── happynrwlapp-e2e/ │ ├── adminapp/ │ └── adminapp-e2e/ ├── libs/ │ ├── happynrwlapp/ │ │ ├── feature-main/ │ │ ├── ui-table/ │ │ └── utils-testing/ │ ├── adminapp/ │ │ ├── feature-main/ │ │ ├── feature-login/ │ │ ├── ui/ │ │ └── utils-testing/ │ └── shared/ │ ├── ui/ │ └── utils-testing/ ├── tools/ ├── angular.json ├── nx.json ├── package.json ├── tsconfig.json └── tslint.json 对于较大的项目，最好将库分组到应用程序部分: happynrwl/ ├── apps/ ├── libs/ │ ├── happynrwlapp/ │ │ ├── registration/ │ │ │ ├── feature-main/ │ │ │ ├── feature-login/ │ │ │ ├── ui-form/ │ │ │ └── utils-testing/ │ │ ├── search/ │ │ │ ├── feature-results/ │ │ │ └── utils-testing/ │ │ └── shared/ │ │ └── ui/ │ ├── adminapp/ | └── shared/ │ ├── ui/ │ └── utils-testing/ ├── tools/ ├── angular.json ├── nx.json ├── package.json ├── tsconfig.json └── tslint.json 这里： happynrwlapp/registration/feature-main- 在一个地方使用的范围库 happynrwlapp/shared/ui- 在单个应用程序中使用的共享库 shared/ui- 跨应用程序使用的共享库 懒加载库 Lazing加载此代码有助于捆绑包大小，减少应用程序的启动时间： ng g @nrwl/angular:lib todo-list-shell --router --lazy --parentModule=apps/todos/src/app/app.module.ts --routing：添加路由器配置。 --lazy：RouterModule.forChild设置为true时添加，设置为false时为简单路径数组。 --parentModule：更新父模块。 myorg/ ├── apps/ │ ├── todos/ │ ├── todos-e2e/ │ └── api/ ├── libs/ │ └── todo-list-shell/ │ ├── jest.conf.js │ ├── src/ │ │ ├── lib/ │ │ │ ├── todo-list-shell.module.spec.ts │ │ │ └── todo-list-shell.module.ts │ │ └── index.ts │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json todo-list-shell.module.ts: import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router'; @NgModule({ imports: [ CommonModule, RouterModule.forChild([ /* {path: '', pathMatch: 'full', component: InsertYourComponentHere} */ ]) ] }) export class FeatureShellModule {} 添加组件，现在将一个组件添加到新创建的todo-list-shell库中： ng g component main --project=todo-list-shell myorg/ ├── apps/ │ ├── todos/ │ ├── todos-e2e/ │ └── api/ ├── libs/ │ └── todo-list-shell/ │ ├── jest.conf.js │ ├── src/ │ │ ├── lib/ │ │ │ ├── todo-list/ │ │ │ │ ├── todo-list.component.css │ │ │ │ ├── todo-list.component.html │ │ │ │ ├── todo-list.component.spec.ts │ │ │ │ └── todo-list.component.ts │ │ │ ├── todo-list-shell.module.spec.ts │ │ │ └── todo-list-shell.module.ts │ │ └── index.ts │ ├── tsconfig.app.json │ ├── tsconfig.json │ ├── tsconfig.spec.json │ └── tslint.json ├── nx.json ├── package.json ├── tools/ ├── tsconfig.json └── tslint.json 接下来，更新TodoListShellModule以使用组件： import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router'; import { TodoListComponent } from './todo-list/todo-list.component'; @NgModule({ imports: [ CommonModule, RouterModule.forChild([ { path: '', pathMatch: 'full', component: TodoListComponent } ]) ] }) export class TodoListShellModule {} app.module.ts通过使用loadChildren属性添加惰性路由: import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; // You can add multiple routes as your needs const routes: Routes = [ { path: 'list', loadChildren: () =&gt; import('@myorg/todo-list-shell').then(m =&gt; m.TodoListShellModule) } ]; @NgModule({ declarations: [AppComponent], imports: [BrowserModule, RouterModule.forRoot(routes)], providers: [], bootstrap: [AppComponent] }) export class AppModule {} 快捷使用 创建 app 和 lib 创建App： yarn ng g @nrwl/angular:application demo --routing --style=less。添加参数 --dry-run （或 -d 简写）来查看当前操作将会创建的文件 创建Lib： yarn ng g lib demo --routing --lazy --parent-module=apps/demo/src/app/app.module.ts --directory=demo/views。 修改 angular.json： { &quot;projects&quot;: { &quot;demo&quot;: { &quot;architect&quot;: { &quot;build&quot;: { &quot;options&quot;: { &quot;styles&quot;: [ &quot;apps/demo/src/styles.less&quot;, // 引用当前 app 的样式 + &quot;styles/styles.less&quot; // 引用全局公共样式 ], }, &quot;configurations&quot;: { &quot;production&quot;: { + &quot;baseHref&quot;: &quot;/&quot;, } } }, &quot;serve&quot;: { &quot;options&quot;: { + &quot;port&quot;: 5001, // 每个 app 设置不一样的端口 + &quot;proxyConfig&quot;: &quot;proxy.conf.js&quot;, } } } } } } 配置热更新 ","link":"https://fanguyun214.github.io/post/nxdev/"},{"title":"Apollo Client - 16.Authentication","content":"认证、除非您加载的所有数据都是完全公开的，否则您的应用程序应该拥有用户，帐户和权限系统。 如果不同的用户在您的应用程序中具有不同的权限，那么您需要一种方法来告诉服务器哪个用户与每个请求相关联。 Apollo客户端使用超灵活的 Apollo Link，其中包括几个身份验证选项。 Cookie 如果您的应用程序是基于浏览器的，并且您使用 cookie 进行后端登录和会话管理，则很容易告诉您的网络接口，发送 cookie 到每个请求。 您只需要传递凭证选项。 例如 credentials：'same-origin' 如果你的后端服务器是同一个域，或者如果你的后端是一个不同的域，则为 credentials：'include'。 const link = createHttpLink({ uri: '/graphql', credentials: 'same-origin' }); const client = new ApolloClient({ cache: new InMemoryCache(), link, }); 这个选项简单地传递给 HttpLink 在发送查询时使用的 fetch implementation 注意：后端还必须允许来自请求来源的凭据。 例如 如果在 node.js 中使用来自 npm 的流行 'cors' 包，则以下设置将与上述 apollo 客户端设置协同工作， // enable cors var corsOptions = { origin: '&lt;insert uri of front-end domain&gt;', credentials: true // &lt;-- REQUIRED backend setting }; app.use(cors(corsOptions)); Header 使用 HTTP 时识别自己的另一种常用方法是基于 header 发送认证。通过将 Apollo Links 结合在一起，可以轻松地为每个 HTTP 请求添加一个 authorization 标头。 在这个例子中，每次发送请求时我们都会从 localStorage 中提取登录令牌： import { ApolloClient } from 'apollo-client'; import { createHttpLink } from 'apollo-link-http'; import { setContext } from 'apollo-link-context'; import { InMemoryCache } from 'apollo-cache-inmemory'; const httpLink = createHttpLink({ uri: '/graphql', }); const authLink = setContext((_, { headers }) =&gt; { // get the authentication token from local storage if it exists const token = localStorage.getItem('token'); // return the headers to the context so httpLink can read them return { headers: { ...headers, authorization: token ? `Bearer ${token}` : &quot;&quot;, } } }); const client = new ApolloClient({ link: authLink.concat(httpLink), cache: new InMemoryCache() }); 请注意，上面的示例使用了 apollo-client 包中的 ApolloClient。 虽然可以使用 apollo-boost 包中的 ApolloClient 修改 Headers，但由于 apollo-boost 不允许修改它所使用的 HttpLink 实例，所以 Headers 必须作为配置参数传入。 有关详细信息，请参阅 Apollo Boost 配置选项 部分。 服务器可以使用 header 信息对用户进行身份验证并将其附加到 GraphQL 执行上下文，因此解析器可以根据用户的角色和权限修改其行为。 注销时重置存储 由于 Apollo 会缓存您的所有查询结果，因此在登录状态更改时删除它们非常重要。 确保 UI 和存储状态反映的是当前用户权限的最简单方法是在登录或注销过程完成后调用 client.resetStore()。 这将导致清除存储并重新获取所有查询。 如果您只想清除存储并且不想重新获取查询，请使用 client.clearStore()。 另一种选择是重新加载页面，产生类似的效果。 const PROFILE_QUERY = gql` query CurrentUserForLayout { currentUser { login avatar_url } } `; const Profile = () =&gt; ( &lt;Query query={PROFILE_QUERY} fetchPolicy=&quot;network-only&quot;&gt; {({ client, loading, data: { currentUser } }) =&gt; { if (loading) { return &lt;p className=&quot;navbar-text navbar-right&quot;&gt;Loading...&lt;/p&gt;; } if (currentUser) { return ( &lt;span&gt; &lt;p className=&quot;navbar-text navbar-right&quot;&gt; {currentUser.login} &amp;nbsp; &lt;button onClick={() =&gt; { // call your auth logout code then reset store App.logout().then(() =&gt; client.resetStore()); }} &gt; Log out &lt;/button&gt; &lt;/p&gt; &lt;/span&gt; ); } return ( &lt;p className=&quot;navbar-text navbar-right&quot;&gt; &lt;a href=&quot;/login/github&quot;&gt;Log in with GitHub&lt;/a&gt; &lt;/p&gt; ); }} &lt;/Query&gt; ); ","link":"https://fanguyun214.github.io/post/apollo-client-16authentication/"},{"title":"Apollo Client - 2.Query","content":"学习如何使用 Query 组件获取数据 以简单可预测的方式获取数据是 Apollo Client 的核心功能之一。 在本指南中，您将学习如何构建 Query 组件以获取 GraphQL 数据并将结果附加到 UI。 您还将了解 Apollo Client 如何通过跟踪错误和加载状态来简化数据管理代码。 假设您熟悉构建 GraphQL 查询。 如果你想复习一下, 我们推荐 阅读本指南 和练习 在GraphiQL中运行查询. 由于 Apollo Client 查询是标准的 GraphQL，因此您在 GraphiQL 中成功运行的任何查询也将在 Apollo Query 组件中运行。 以下示例假设您已经设置了 Apollo Client 并将您的 React 应用程序包装在 ApolloProvider 组件中。 阅读我们的 入门 指南, 如果您需要有关这两个步骤的帮助。 如果你想参考这些例子，请打开 CodeSandbox 上的 启动项目和 this CodeSandbox 上的示例 GraphQL 服务器。 您可以查看应用程序的 完整版本。 Query组件 Query 组件是 Apollo 应用程序最重要的构建块之一。 要创建 Query 组件， 只需将包含 gql 函数的 GraphQL 查询字符串传递给 this.props.query ，并为 this.props.children 提供一个函数，告诉 React 要呈现什么。 Query 组件是使用 render prop 模式的React组件的示例。 React将使用 Apollo Client 中的对象调用您提供的 render prop 函数，该对象包含可用于呈现 UI 的加载，错误和数据属性。 我们来看一个例子： 首先，让我们创建 GraphQL 查询。 请记住将查询字符串包装在 gql 函数中，以便将其解析为查询文档。 一旦我们创建好 GraphQL 查询，让我们通过将它传递给 query prop 来将它附加到我们的 Query 组件。 我们还需要为 Query 组件提供一个子函数，它将告诉 React 我们想要呈现什么。 我们可以使用 Query 组件为我们提供的 loading，error 和 data 属性，以便根据查询的状态智能地呈现不同的 UI。 让我们看看这是什么样的！ import gql from &quot;graphql-tag&quot;; import { Query } from &quot;react-apollo&quot;; const GET_DOGS = gql` { dogs { id breed } } `; const Dogs = ({ onDogSelected }) =&gt; ( &lt;Query query={GET_DOGS}&gt; {({ loading, error, data }) =&gt; { if (loading) return &quot;Loading...&quot;; if (error) return `Error! ${error.message}`; return ( &lt;select name=&quot;dog&quot; onChange={onDogSelected}&gt; {data.dogs.map(dog =&gt; ( &lt;option key={dog.id} value={dog.breed}&gt; {dog.breed} &lt;/option&gt; ))} &lt;/select&gt; ); }} &lt;/Query&gt; ); 如果你在 App 组件中渲染 Dogs，一旦 Apollo Client 从服务器接收数据，你将首先看到加载状态，然后是带有狗品种列表的表单。 当表单值改变时，我们将通过 this.props.onDogSelected 将值发送给父组件， 最终将值传递给 DogPhoto 组件。 在下一步中，我们将通过构建一个 DogPhoto 组件将表单挂载到一个更复杂的变量查询。 接收数据 您已经在 render prop 函数中看到了如何处理查询结果。 当我们从 Query 组件中获取数据时，让我们深入了解 Apollo Client 幕后发生的事情。 当 Query 组件安装时，Apollo Client 会为我们的查询创建一个 observable。 我们的组件通过 Apollo Client 缓存订阅查询结果。 首先，我们尝试 从 Apollo 缓存加载查询结果。 如果缓存中不存在，我们将请求发送到服务器。 一旦数据返回，我们将其标准化并将其存储在 Apollo 缓存中。 由于 Query 组件订阅了结果，因此它会自动更新数据。 要查看 Apollo Client 的缓存操作，让我们构建我们的 DogPhoto 组件。 DogPhoto 接受一个名为 breed 的道具，它反映了上面 Dogs 组件中我们表单的当前值。 const GET_DOG_PHOTO = gql` query Dog($breed: String!) { dog(breed: $breed) { id displayImage } } `; const DogPhoto = ({ breed }) =&gt; ( &lt;Query query={GET_DOG_PHOTO} variables={{ breed }}&gt; {({ loading, error, data }) =&gt; { if (loading) return null; if (error) return `Error!: ${error}`; return ( &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; ); }} &lt;/Query&gt; ); 您会注意到 Query 组件上有一个新的配置选项。 propvariable 是一个包含我们想要传递给 GraphQL 查询的变量对象。 在这种情况下，我们希望将表格中的品种传递给我们的查询。 尝试从列表中选择 &quot;bulldog&quot; 以查看其照片显示。 然后，切换到另一个品种并切换回 &quot;bulldog&quot;。 你会注意到牛头犬照片第二次瞬间加载。 这是 Apollo 缓存在起作用！ 接下来，让我们学习一些确保数据新鲜的技术，例如轮询和重新获取。 轮询和重新获取 Apollo Client 为您缓存数据真是太棒了，但是当我们需要新数据时我们应该怎么做？ 两种解决方案是轮询和重新获取。 轮询可以通过在指定的时间间隔内重新获取来帮助我们实现接近实时的数据。 要实现轮询，只需将 pollInterval prop传递给 Query 组件，间隔为 ms。 如果传入 0，查询将不会轮询。 您还可以通过在传递给 render prop 函数的结果对象上使用 startPolling 和 stopPolling 函数来实现动态轮询。 const DogPhoto = ({ breed }) =&gt; ( &lt;Query query={GET_DOG_PHOTO} variables={{ breed }} skip={!breed} pollInterval={500} &gt; {({ loading, error, data, startPolling, stopPolling }) =&gt; { if (loading) return null; if (error) return `Error!: ${error}`; return ( &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; ); }} &lt;/Query&gt; ); 通过将 pollInterval 设置为 500 ，您应该每隔 0.5 秒看到一个新的狗图像。 轮询是实现近实时数据的绝佳方式，而无需复杂的设置 GraphQL 订阅。 如果要重新加载查询以响应用户操作而不是间隔，该怎么办？ 这就是 refetch 函数的用武之地！ 在这里，我们在 DogPhoto 组件中添加了一个按钮，该按钮会在单击时触发重新获取。refetch 接受变量，但如果我们不传入新变量，它将使用我们之前查询中的相同变量。 const DogPhoto = ({ breed }) =&gt; ( &lt;Query query={GET_DOG_PHOTO} variables={{ breed }} skip={!breed} &gt; {({ loading, error, data, refetch }) =&gt; { if (loading) return null; if (error) return `Error!: ${error}`; return ( &lt;div&gt; &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; &lt;button onClick={() =&gt; refetch()}&gt;Refetch!&lt;/button&gt; &lt;/div&gt; ); }} &lt;/Query&gt; ); 如果单击该按钮，您会注意到我们的 UI 更新了最新的数据。 重新获取是保证新数据的一种很好的方法，但它在加载状态时引入了一些额外的复杂性。 在下一节中，您将学习处理复杂加载和错误状态的策略。 加载和错误状态 我们已经看到 Apollo Client 如何在渲染函数中公开我们的查询的加载和错误状态。 这些属性对于初次查询加载时有用，但是当我们重新获取或轮询时，我们的加载状态会发生什么？ 让我们回到上一节中的示例。 如果单击 “Refetch” 按钮，您将看到组件在新数据到达之前不会重新呈现。 如果我们想向用户表明我们正在重新获取照片怎么办？ 幸运的是，Apollo Client 通过 render prop 函数中结果对象的 networkStatus 属性提供有关查询状态的细粒度信息。 我们还需要将 prop 的 notifyOnNetworkStatusChange 设置为 true ，以便我们的查询组件在重新加载时重新渲染。 const DogPhoto = ({ breed }) =&gt; ( &lt;Query query={GET_DOG_PHOTO} variables={{ breed }} skip={!breed} notifyOnNetworkStatusChange &gt; {({ loading, error, data, refetch, networkStatus }) =&gt; { if (networkStatus === 4) return &quot;Refetching!&quot;; if (loading) return null; if (error) return `Error!: ${error}`; return ( &lt;div&gt; &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt; &lt;button onClick={() =&gt; refetch()}&gt;Refetch!&lt;/button&gt; &lt;/div&gt; ); }} &lt;/Query&gt; ); networkStatus 属性是一个枚举，其数字值为 1-8，表示不同的加载状态。 4 对应重新获取，但也有用于轮询和分页的数字值。 有关所有可能加载状态的完整列表，请查看参考指南。 虽然没有加载状态那么复杂，但是也可以通过 Query 组件上的 errorPolicy prop 来自定义组件中的错误。 errorPolicy 的默认值是 “none” ，我们将所有 GraphQL 错误视为运行时错误。 如果发生错误，Apollo Client 将丢弃随请求返回的任何数据，并将 render prop 函数中的 error 属性设置为 true。 如果您想显示任何部分数据以及任何错误信息，请将 errorPolicy 设置为 “all”。 手动触发查询 当 React 安装一个 Query 组件时，Apollo Client 会自动触发你的查询。 如果您想延迟触发查询，直到用户执行操作（例如单击按钮），该怎么办？ 对于这种情况，我们想要使用 ApolloConsumer 组件并直接调用 client.query()。 import React, { Component } from 'react'; import { ApolloConsumer } from 'react-apollo'; class DelayedQuery extends Component { state = { dog: null }; onDogFetched = dog =&gt; this.setState(() =&gt; ({ dog })); render() { return ( &lt;ApolloConsumer&gt; {client =&gt; ( &lt;div&gt; {this.state.dog &amp;&amp; &lt;img src={this.state.dog.displayImage} /&gt;} &lt;button onClick={async () =&gt; { const { data } = await client.query({ query: GET_DOG_PHOTO, variables: { breed: &quot;bulldog&quot; } }); this.onDogFetched(data.dog); }} &gt; Click me! &lt;/button&gt; &lt;/div&gt; )} &lt;/ApolloConsumer&gt; ); } } 以这种方式获取是非常冗长的，所以我们建议尽可能使用 Query 组件！ 如果您想查看我们刚刚构建的应用程序的完整版本，您可以查看CodeSandbox 此处. Query API 概览 如果您正在寻找所有 Query 组件接受及其渲染方法功能的概述，请不要再看了！ 大多数 Query 组件不需要所有这些配置选项，但知道它们存在是有用的。 如果您想通过使用示例更详细地了解 Query 组件 API，请访问我们的参考指南. Props Query 组件接受以下 props。 只有 query 和 children是必须的 required. `query`: DocumentNode GraphQL查询文档通过`graphql-tag`解析为AST。 **Required** `children`: (result: QueryResult) => React.ReactNode 一个函数，根据查询结果返回要渲染的 UI。**Required** `variables`: { [key: string]: any } 包含执行查询需要的所有变量对象 `pollInterval`: number 指定组件轮询数据的时间间隔（以毫秒为单位）。 默认为 0（无轮询）。 `notifyOnNetworkStatusChange`: boolean 是否更新网络状态或网络错误应重新呈现组件。 默认为false。 `fetchPolicy`: FetchPolicy 您希望组件如何与 Apollo 缓存交互。 默认为 “cache-first”。 `errorPolicy`: ErrorPolicy 您希望组件如何处理网络和 GraphQL 错误。 默认为 “none”，这意味着我们将 GraphQL 错误视为运行时错误。 `ssr`: boolean 传入 false 以在服务端渲染期间跳过查询。 `displayName`: string 要在 React DevTools 中显示的组件的名称。 默认为 'Query'。 `skip`: boolean 如果 skip 为 true，则将完全跳过查询。 `onCompleted`: (data: TData | {}) => void 查询成功完成后执行的回调。 `onError`: (error: ApolloError) => void 发生错误时执行的回调。 `context`: Record 查询组件与网络接口（Apollo Link）之间的共享上下文。 用于从道具设置标题或将信息发送到 Apollo Boost 的 `request` 功能。 `partialRefetch`: boolean 如果是 `true`，如果查询结果被标记为部分，则执行查询 `refetch`，并且由 Apollo Client `QueryManager` 将返回的数据重置为空对象（由于高速缓存未命中）。 出于向后兼容性的原因，默认值为 “false”，但对于大多数实例，应将其更改为true。 Render prop function 使用具有以下属性的对象（QueryResult）调用传递给 Query 的 children prop 的 render prop 函数。 此对象包含您的查询结果，以及一些有用的函数，用于重新获取，动态轮询和分页。 `data`: TData 包含 GraphQL 查询结果的对象。 默认为空对象。 `loading`: boolean 一个布尔值，指示请求是否在执行中 `error`: ApolloError 使用 `graphQLErrors` 和 `networkError` 属性的运行时错误 `variables`: { [key: string]: any } 包含调用查询的变量对象 `networkStatus`: NetworkStatus 1-8 之间的数字，对应网络请求的详细状态。 包括有关重新获取和轮询状态的信息。 与 `notifyOnNetworkStatusChange` 道具一起使用。 `refetch`: (variables?: TVariables) => Promise 一个允许您重新获取查询并可选地传入新变量的函数 `fetchMore`: ({ query?: DocumentNode, variables?: TVariables, updateQuery: Function}) => Promise 为您的查询启用 [pagination](../features/pagination.html) 的函数 `startPolling`: (interval: number) => void 此函数以 ms 为单位设置间隔，并在每次指定的间隔通过时获取查询。 `stopPolling`: () => void 此函数停止查询轮询。 `subscribeToMore`: (options: { document: DocumentNode, variables?: TVariables, updateQuery?: Function, onError?: Function}) => () => void 设置 [subscription](../advanced/subscriptions.html) 的函数。 `subscribeToMore` 返回一个可用于取消订阅的函数。 `updateQuery`: (previousResult: TData, options: { variables: TVariables }) => TData 函数，允许您在获取，变异或订阅的上下文之外的缓存中更新查询的结果 `client`: ApolloClient 你的 'ApolloClient` 实例。 用于手动触发查询或将数据写入。 下一步 学习如何构建 Query 组件来获取数据是掌握 Apollo Client 开发的最重要技能之一。 既然您是获取数据的专家，为什么不尝试构建 Mutation 组件来更新您的数据？ 以下是我们认为可以帮助您提升技能的一些资源： Mutations: 了解如何使用突变更新数据以及何时需要更新 Apollo 缓存。 有关选项的完整列表，请查看 Mutation 组件的API参考。 Local state management: 学习如何使用 apollo-link-state 查询本地数据。 Pagination: 基于 Apollo Client 的 fetchMore 功能，构建列表从未如此简单。 在我们的分页教程中了解更多信息。 Query component video by Sara Vieira: 如果您需要通过观看视频进行复习或学习，请查看 Sara 的 Query 组件的教程！ ","link":"https://fanguyun214.github.io/post/apollo-client-query/"},{"title":"Gitlab-CI前端持续集成","content":"gitlab-ci 全称是 gitlab continuous integration，也就是基于gitlab的持续集成工具。 1、Gitlab-ci &amp;&amp; Gitlab-ci-runner gitlab-ci 中心思想是当每一次push到gitlab的时候，都会触发一次脚本执行，然后脚本的内容包括了测试，编译，部署等一系列自定义的内容。高版本的 GitLab 自带了 GitLab CI，所以不需要另外安装。 GitLab-Runner GitLab-Runner 是脚本执行的承载者，GitLab-CI 事先注册好 GitLab-Runner，再 push 代码，对应的 Runner 就会执行你所定义的脚本。 本地push -&gt; .gitlab-ci.yml配置 -&gt; GitLab-Runner执行脚本 -&gt; 部署开发、测试、生产服务器 2、安装GitLab-Runner Gitlab Runner安装方式有两种，一种是直接二进制文件安装，一种是基于docker镜像安装。 二进制文件安装 下载对应操作系统的二进制包，我这里使用的是mac版本， sudo curl --output /usr/local/bin/gitlab-ci-multi-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-darwin-amd64 给 gitlab-ci-multi-runner 设置权限 sudo chmod +x /usr/local/bin/gitlab-ci-multi-runner 以上是官方安装文档，如果有问题，可以手动到版本下载列表下载对应的版本，然后复制到/usr/local/bin/目录下 注册runner 首先，进入到你的 gitlab 项目网页，找到 Settings -&gt; CI/CD -&gt; Runner，然后找到对应的 url 和 token 然后在终端输入 依次是url,token,描述,tag,是否共享,执行方式 启动Runner，gitlab-ci-multi-runner start，刷新页面 说明注册成功了。 我们可以通过 gitlab-ci-multi-runner list 查询你注册的runner ，用 gitlab-ci-multi-runner status 查看 runner 服务是否运行中。 基于Docker安装 先获取 gitlab-runner 镜像 sudo docker pull gitlab/gitlab-runner:latest 启动 gitlab-runner container sudo docker run -d --name gitlab-runner --restart always \\ -v /srv/gitlab-runner/config:/etc/gitlab-runner \\ -v /var/run/docker.sock:/var/run/docker.sock \\ gitlab/gitlab-runner:latest 注册runner sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register 注册方式同上 3、配置.gitlab-ci.yml GitLab CI的一切工作，都是由 .gitlab-ci.yml 来配置的。详细文档可以参考这里 在项目根目录下创建 .gitlab-ci.yml 文件 # 设置缓存 cache: paths: - node_modules/ - dist/ # 定义 stages，用来定义工作阶段，多个 stages 会按顺序进行 stages: - build - test - deploy # before_script 会在每个 stages 执行之前运行 before_script: - node -v - yarn --version - yarn global add umi - yarn install # 测试（对应上面stages） test: stage: test script: - echo 'yarn test' - yarn test # 构建 build: stage: build script: - echo 'yarn build' - yarn build when: manual # 手动触发 # 部署 deploy: stage: deploy only: - master script: - bash scripts/deploy.sh # 部署脚本文件 when: manual 配置完成提交Gitpab后，每次push都会触发gitlab-ci。 4.参考资料 gitlab-runner 安装 gitlab ci yaml 配置 【后端】gitlab之gitlab-ci自动部署 前端基于SSH的自动部署 ","link":"https://fanguyun214.github.io/post/gitlab-ci-qian-duan-chi-xu-ji-cheng/"},{"title":"前端基于SSH的自动部署","content":"SSH是一种网络协议，用于计算机之间的加密登录。 ssh简介 原理： 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 当远程主机的公钥被接受以后，它就会被保存在本地文件~/.ssh/known_hosts之中，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。 常用指令 本地登录服务器 ssh user@remote -p port，端口是22的话ssh user@remote，退出登录exit 本地免密码登录 ssh-copy-id user@remote -p port，这在写脚本服务器控制时特别有用 给服务器配置别名 code ~/.ssh/config追加一些内容，就可以ssh selfname登录，不再需要记服务器ip地址了 执行命令ssh selfname &quot;cd ~;ls&quot;，将会在服务器上执行引号里的命令，执行之后其自动关闭远程服务 将a电脑文件(夹)复制到b电脑上哪个文件夹下面：scp username@a电脑ip:文件路径 username@b电脑ip:文件夹路径，是文件夹的话加上-r，这里也可以用别名，通常本机的话省略username@a电脑ip: ssh user@remote -p port # user 是你在远程机器上的用户名，如果不指定的话默认为当前用户 # remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名 # port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22 # 比如我常用的 ssh zhm@120.79.52.223 通常在本地电脑输入以上命令之后，远程服务器就会询问密码，你输入的时候是看不见任何波动，输入完回车就可以了~，如果报错ssh: connect to host remote port 22: Connection refused，说明服务器没有按照ssh server，Ubantu Desktop系统默认是没有这个的，安装命令sudo apt-get install openssh-server 免密登录 每次 ssh 都要输入密码是不是很烦呢？与密码验证相对的，是公钥验证。也就是说，要实现免密码登入，首先要设置 SSH 钥匙。也就是本地电脑生成公钥私钥，然后把公钥放在远程服务器上就可以了！ 原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。 # 查看本地有没有 ls ~/.ssh # 没有就生成 ssh-keygen # 在~/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。 # 把公钥放到远程服务器 ssh-copy-id user@remote -p port # 比如我的 ssh-copy-id zhm@120.79.52.223 ssh-copy-id基本都安装了，万一没有，mac上brew install ssh-copy-id。 windows麻烦点ssh user@remote -p port 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub，意思是在远端执行新建 .ssh 文件夹，并把本地的 ~/.ssh/id_rsa.pub （也就是公钥）追加到远端的 .ssh/authorized_keys 中。当然，不使用这条命令的话，你也可以手动操作这个过程，即先复制公钥，再登入远程机器，粘贴到 .ssh/authorized_keys 当中。 配置别名 每次都输入 ssh user@remote -p port，时间久了也会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。比如我想用ssh lab替换上面一串 # cat&gt;&gt;某文件&lt;&lt;EOF追加下内容， &gt;&gt; 追加的意思 &lt;&lt;EOF 遇到EOF终止 # 因为是前端，直接用vscode编辑 code ~/.ssh/config # 追加以下内容，保存 Host lab HostName remote User user Port port # 来登录吧 ssh lab # 比如我的 # Host han # HostName 120.79.52.223 # User zhm # Port 22 # ssh han 命令行执行登录并且在目标服务器上执行命令 命令行执行登录并且在目标服务器上执行命令: # 单引号或者双引号，将命令包起来，然后分号隔开命令 ssh user@remoteNode &quot;cd /home ; ls&quot; 如果是很多命令的话，需要建一个脚本。 # 建一个脚本文件test.sh，里面写上这个，然后执行 sh test.sh #!/bin/bash # 远程执行的内容在&quot;&lt; &lt; remotessh &quot; 至&quot; remotessh &quot;之间，如果不想本机出现日志的话 ssh user@remoteNode &gt;/dev/null 2&gt;&amp;1 &lt;&lt; remotessh ssh user@remoteNode &lt;&lt; remotessh ls exit remotessh 传输文件 两台机器间文件传输可以用scp，它的地址格式与 ssh 基本相同，都是可以省略用户名和端口，稍微的差别在与指定端口时用的是大写的 -P 而不是小写的。不过，如果你已经配置了别名，那么这都不重要，因为 scp 也支持直接用别名 # 总的：本机的可以省略电脑的ip，默认的远程当前文件夹是 Home目录（~），将A电脑上的文件复制到B电脑上 # 注意的地方：A若是文件，B电脑若也是文件的路径，不管文件存不存在，都会将A文件内容写入到B这个文件。 # B电脑若是文件夹，不管文件夹存不存在，都会在这个文件夹下生成A电脑同名的文件和内容，有的话则会覆盖同名文件 # A若是文件夹，加上-r，B电脑若是文件的路径会报错，B电脑若是文件夹路径，文件夹不存在的话则会建立这个文件夹且放入A文件夹里面的内容（相当于将A文件夹挪过去然后重命名），文件夹存在的话，会在这个文件夹下面生成一个和A同名的文件夹，里面内容一致 scp A电脑:文件路径 B电脑:文件路径 # 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file scp -P port /path/to/local/file user@remote:/path/to/remote/file # 也可以使用别名 scp /path/to/local/file lab:/path/to/remote/file # 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file scp lab:/path/to/remote/file /path/to/local/file # 远程的默认路径是家目录 # 下面命令把当前目录下的 file 传到远程的 ~/dir/file scp file lab:dir/file # 加上 -r 命令可以传送文件夹 # 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下 scp -r dir lab: # 别忘了 . 可以用来指代当前目录 # 下面命令可以把远程的 ~/dir 目录下载到当前目录里面 scp -r lab:dir/ . 如果觉得使用命令行传输文件浑身不自在，你还可以使用 SFTP 协议。任何支持 SFTP 协议的客户端都能用你的 SSH 账号信息登入并管理文件，比如开源的有图形化界面的FTP客户端 FileZilla。别忘了，在这些客户端里面，你也可以指定你的私钥（~/.ssh/id_rsa），然后就能做到无密码登入了。 保持程序在后台运行 以下命令均在服务器执行 nohup # 让程序在后台运行 比如 nohup node index.js &amp; nohup 一直执行的命令 &amp; # 看下任务号 node的那个 ps # 如果需要终止的话 kill 21455 tmux tmux更能执行复杂的程序，tmux还能管理多个窗口，窗口切分，复制粘贴等等，mac用户使用tmux更方便，新建会话tmux -CC，恢复的时候tmux -CC attach # 服务器上安装tmux sudo apt-get install tmux # 运行tmux，进入会话，此时运行任何东西都不会因为退出ssh而被杀死 tmux # 暂时离开会话 ctrl+b 再按下d # 恢复会话 # tmux attach # tmux命令必须运行在服务器上 以上内容来自ssh免密登录服务器和scp的使用 基于rsync的部署 参考rsync 的使用方法 scp和rsync的区别 scp命令 1.scp 是 secure copy 的缩写，用于远程的文件的复制。 2.参数： -r： 递归复制整个目录。 3.实例： scp /home/space/music/1.mp3 username@ip/home/root/others/music scp /home/space/music/1.mp3 username@ip/home/root/others/music/001.mp3 如果是远程复制目录就加上 -r 参数 即可（重命名目录，就直接在命令后面添加，前提保证目标地址没有该目录） scp -r /home/space/music/ username@ip:/home/root/others/music_new 把本地music目录复制到另一台服务器的others下，并重命名为music_new rsync 1.rsync 是 remote sync 的缩写，用于linux系统下的数据镜像备份工具，远程服务器之间的文件拷贝。 2.参数： -a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。 -v, --verbose 详细模式输出。 -z, --compress 对备份的文件在传输时进行压缩处理。 -P, --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 3.实例： rsync -avp mylog /home/ scp是相当于复制，黏贴，如果有的话是覆盖，比较耗时间，不智能。 rsync是复制，如果有重复的文件，会直接跳过，而且他自己的算法优化。 scp是把文件全部复制过去，当文件修改后还是把所有文件复制过去，rsync 第一次是把所有文件同步过去，当文件修改后，只把修改的文件同步过去。 前端基于scp或rsync的自动部署 1、基于scp,新增部署脚本文件，如deploy.sh # 压缩文件，其中 dist为要上传的文件所在目录 echo 压缩部署包！ tar -zcvf dist.tar.gz dist/ # 上传到服务器（需要输入密码，如果已经进行过私钥配置，则不用），其中/home/savoygu/gusaifei 为上传文件所在目录 echo 上传文件 scp -r dist.tar.gz 账号@服务器ip:服务器上传路径 # 登录到服务器（需要输入密码，如果已经进行过私钥配置，则不用） # 服务器环境开启 ssh 账号@服务器ip -tt &lt;&lt; EOF # 进入目标目录 cd 服务器上传路径 # 解压 sudo tar -zxvf dist.tar.gz --strip-components 1 # 移除线上压缩文件 sudo rm -rf exit EOF # 服务器环境结束 echo 上传完成！ # 移除本地压缩文件 echo 删除本地压缩包！ rm -rf dist.tar.gz 使用rsync同理 2、前端使用脚本 &quot;scripts&quot;: { &quot;deploy&quot;: &quot;cross-env NODE_ENV=production umi build &amp;&amp; ./deploy.sh&quot; } 可结合gitlabCI，Travis CI实现持续集成，参考 持续集成服务 gitlabCI教程 持续集成服务 Travis CI教程 错误处理 1、权限问题 .ssh目录，以及/home/当前用户 需要700权限，参考以下操作调整 sudo chmod 700 ~/.ssh sudo chmod 700 /home/当前用户 .ssh目录下的authorized_keys文件需要600或644权限，参考以下操作调整 sudo chmod 600 ~/.ssh/authorized_keys 2、StrictModes问题 编辑 sudo vi /etc/ssh/sshd_config 找到 #StrictModes yes 改成 StrictModes no ","link":"https://fanguyun214.github.io/post/qian-duan-ji-yu-ssh-de-zi-dong-bu-shu/"},{"title":"使用commitizen的正确姿势 ","content":"我们在每次提交代码时，都需要编写Commit Message，否则是不允许提交的。 git commit -m “first commit with userInfo service” 编写Commit Message需要遵循一定的范式，内容应该清晰明了，指明本次提交的目的，便于日后追踪问题。 commitizen就是这么样一款工具,他用来规范化我们的commit消息。 安装指南 安装commitizen sudo npm install -g commitizen 配置 cd到.git所在目录 commitizen init cz-conventional-changelog --save --save-exact 使用 用git cz命令来取代git commit npm install --global cz-emoji set as default adapter for your projects echo '{ &quot;path&quot;: &quot;cz-emoji&quot; }' &gt; ~/.czrc 异常情况 有可能提示你缺少package.json 配置第二个项目 当我们配置第二个项目的时候我们只需要进入到对应的.git文件夹下，输入如下的命令 commitizen init cz-conventional-changelog --force 我们就可以使用git cz命令了 commitizen详解 Message 格式 一般来说，Commit Message 应包含三部分内容：Header、Body、Footer &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; &lt;body&gt; &lt;footer&gt; Header Header部分应只包含一行，包括三个字段：type、scope和subject type type用于说明Commit的类型，包含一下7种类型 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 scope scope用于说明本次Commit所影响的范围，比如controller、user或者README，视项目的不同而不同 subject subject是本次Commit目的的简短描述，一般不要超过50个字符 以动词开头，使用第一人称现在时，比如change，而不是changed或changes ","link":"https://fanguyun214.github.io/post/shi-yong-commitizen-de-zheng-que-zi-shi/"},{"title":"Redux简介","content":"redux 是一个状态管理器，redux 和 react 没有关系，redux 可以用在任何框架中，忘掉 react。 connect 不属于 redux，它其实属于 react-redux。 请一定先忘记 reducer、store、dispatch、middleware 等等这些名词。 createStore 创建 store 对象，包含 getState, dispatch, subscribe, replaceReducer reducer reducer 是一个计划函数，接收旧的 state 和 action，生成新的 state action action 是一个对象，必须包含 type 字段 dispatch dispatch( action ) 触发 action，生成新的 state subscribe 实现订阅功能，每次触发 dispatch 的时候，会执行订阅函数 combineReducers 多 reducer 合并成一个 reducer replaceReducer 替换 reducer 函数 middleware 扩展 dispatch 函数！ Redux流程图 ","link":"https://fanguyun214.github.io/post/redux-jian-jie/"}]}