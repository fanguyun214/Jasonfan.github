<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://fanguyun214.github.io</id>
    <title>Jasonfan</title>
    <updated>2019-07-18T15:27:09.888Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://fanguyun214.github.io"/>
    <link rel="self" href="http://fanguyun214.github.io/atom.xml"/>
    <subtitle>持之以恒，挑战自我 🌱🌱🌱</subtitle>
    <logo>http://fanguyun214.github.io/images/avatar.png</logo>
    <icon>http://fanguyun214.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, Jasonfan</rights>
    <entry>
        <title type="html"><![CDATA[Apollo Client - 16.Authentication]]></title>
        <id>http://fanguyun214.github.io/post/apollo-client-16authentication</id>
        <link href="http://fanguyun214.github.io/post/apollo-client-16authentication">
        </link>
        <updated>2019-07-18T15:02:35.000Z</updated>
        <summary type="html"><![CDATA[<p>认证、除非您加载的所有数据都是完全公开的，否则您的应用程序应该拥有用户，帐户和权限系统。</p>
]]></summary>
        <content type="html"><![CDATA[<p>认证、除非您加载的所有数据都是完全公开的，否则您的应用程序应该拥有用户，帐户和权限系统。</p>
<!-- more -->
<p>如果不同的用户在您的应用程序中具有不同的权限，那么您需要一种方法来告诉服务器哪个用户与每个请求相关联。</p>
<p>Apollo客户端使用超灵活的 <a href="/docs/link">Apollo Link</a>，其中包括几个身份验证选项。</p>
<h2 id="cookie">Cookie</h2>
<p>如果您的应用程序是基于浏览器的，并且您使用 cookie 进行后端登录和会话管理，则很容易告诉您的网络接口，发送 cookie 到每个请求。 您只需要传递凭证选项。 例如 <code>credentials：'same-origin'</code> 如果你的后端服务器是同一个域，或者如果你的后端是一个不同的域，则为 <code>credentials：'include'</code>。</p>
<pre><code class="language-js">const link = createHttpLink({
  uri: '/graphql',
  credentials: 'same-origin'
});

const client = new ApolloClient({
  cache: new InMemoryCache(),
  link,
});
</code></pre>
<p>这个选项简单地传递给 HttpLink 在发送查询时使用的 <a href="https://github.com/github/fetch"><code>fetch</code> implementation</a></p>
<p>注意：后端还必须允许来自请求来源的凭据。 例如 如果在 node.js 中使用来自 npm 的流行 'cors' 包，则以下设置将与上述 apollo 客户端设置协同工作，</p>
<pre><code class="language-js">// enable cors
var corsOptions = {
  origin: '&lt;insert uri of front-end domain&gt;',
  credentials: true // &lt;-- REQUIRED backend setting
};
app.use(cors(corsOptions));
</code></pre>
<h2 id="header">Header</h2>
<p>使用 HTTP 时识别自己的另一种常用方法是基于 header 发送认证。通过将 Apollo Links 结合在一起，可以轻松地为每个 HTTP 请求添加一个 <code>authorization</code> 标头。 在这个例子中，每次发送请求时我们都会从 <code>localStorage</code> 中提取登录令牌：</p>
<pre><code class="language-js">import { ApolloClient } from 'apollo-client';
import { createHttpLink } from 'apollo-link-http';
import { setContext } from 'apollo-link-context';
import { InMemoryCache } from 'apollo-cache-inmemory';

const httpLink = createHttpLink({
  uri: '/graphql',
});

const authLink = setContext((_, { headers }) =&gt; {
  // get the authentication token from local storage if it exists
  const token = localStorage.getItem('token');
  // return the headers to the context so httpLink can read them
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : &quot;&quot;,
    }
  }
});

const client = new ApolloClient({
  link: authLink.concat(httpLink),
  cache: new InMemoryCache()
});
</code></pre>
<p>请注意，上面的示例使用了 <code>apollo-client</code> 包中的 <code>ApolloClient</code>。 虽然可以使用 <code>apollo-boost</code> 包中的 <code>ApolloClient</code> 修改 Headers，但由于 <code>apollo-boost</code> 不允许修改它所使用的 <code>HttpLink</code> 实例，所以 Headers 必须作为配置参数传入。 有关详细信息，请参阅 Apollo Boost <a href="../essentials/get-started.html#configuration">配置选项</a> 部分。</p>
<p>服务器可以使用 header 信息对用户进行身份验证并将其附加到 GraphQL 执行上下文，因此解析器可以根据用户的角色和权限修改其行为。</p>
<h2 id="login-logout">注销时重置存储</h2>
<p>由于 Apollo 会缓存您的所有查询结果，因此在登录状态更改时删除它们非常重要。</p>
<p>确保 UI 和存储状态反映的是当前用户权限的最简单方法是在登录或注销过程完成后调用 <code>client.resetStore()</code>。 这将导致清除存储并重新获取所有查询。 如果您只想清除存储并且不想重新获取查询，请使用 <code>client.clearStore()</code>。 另一种选择是重新加载页面，产生类似的效果。</p>
<pre><code class="language-js">const PROFILE_QUERY = gql`
  query CurrentUserForLayout {
    currentUser {
      login
      avatar_url
    }
  }
`;

const Profile = () =&gt; (
  &lt;Query query={PROFILE_QUERY} fetchPolicy=&quot;network-only&quot;&gt;
    {({ client, loading, data: { currentUser } }) =&gt; {
      if (loading) {
        return &lt;p className=&quot;navbar-text navbar-right&quot;&gt;Loading...&lt;/p&gt;;
      }
      if (currentUser) {
        return (
          &lt;span&gt;
            &lt;p className=&quot;navbar-text navbar-right&quot;&gt;
              {currentUser.login}
              &amp;nbsp;
              &lt;button
                onClick={() =&gt; {
                  // call your auth logout code then reset store
                  App.logout().then(() =&gt; client.resetStore());
                }}
              &gt;
                Log out
              &lt;/button&gt;
            &lt;/p&gt;
          &lt;/span&gt;
        );
      }
      return (
        &lt;p className=&quot;navbar-text navbar-right&quot;&gt;
          &lt;a href=&quot;/login/github&quot;&gt;Log in with GitHub&lt;/a&gt;
        &lt;/p&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Apollo Client - 2.Query]]></title>
        <id>http://fanguyun214.github.io/post/apollo-client-query</id>
        <link href="http://fanguyun214.github.io/post/apollo-client-query">
        </link>
        <updated>2019-07-18T13:58:56.000Z</updated>
        <summary type="html"><![CDATA[<p>学习如何使用 Query 组件获取数据</p>
]]></summary>
        <content type="html"><![CDATA[<p>学习如何使用 Query 组件获取数据</p>
<!-- more -->
<p>以简单可预测的方式获取数据是 Apollo Client 的核心功能之一。 在本指南中，您将学习如何构建 Query 组件以获取 GraphQL 数据并将结果附加到 UI。 您还将了解 Apollo Client 如何通过跟踪错误和加载状态来简化数据管理代码。</p>
<p>假设您熟悉构建 GraphQL 查询。 如果你想复习一下, 我们推荐 <a href="http://graphql.org/learn/queries/">阅读本指南</a> 和练习 <a href="../features/developer-tooling.html#features">在GraphiQL中运行查询</a>. 由于 Apollo Client 查询是标准的 GraphQL，因此您在 GraphiQL 中成功运行的任何查询也将在 Apollo Query 组件中运行。</p>
<p>以下示例假设您已经设置了 Apollo Client 并将您的 React 应用程序包装在 <code>ApolloProvider</code> 组件中。 阅读我们的 <a href="./get-started.html">入门</a> 指南, 如果您需要有关这两个步骤的帮助。</p>
<blockquote>
<p>如果你想参考这些例子，请打开 CodeSandbox 上的 <a href="https://codesandbox.io/s/j2ly83749w">启动项目</a>和 <a href="https://codesandbox.IO/S/32ypr38l61">this CodeSandbox</a> 上的示例 GraphQL 服务器。 您可以查看应用程序的 <a href="https://codesandbox.io/s/n3jykqpxwm">完整版本</a>。</p>
</blockquote>
<h2 id="query组件">Query组件</h2>
<p>Query 组件是 Apollo 应用程序最重要的构建块之一。 要创建 Query 组件， 只需将包含 <code>gql</code> 函数的 GraphQL 查询字符串传递给 <code>this.props.query</code> ，并为 <code>this.props.children</code> 提供一个函数，告诉 React 要呈现什么。<br>
<code>Query</code> 组件是使用 <a href="https://reactjs.org/docs/render-props.html">render prop</a> 模式的React组件的示例。 React将使用 Apollo Client 中的对象调用您提供的 render prop 函数，该对象包含可用于呈现 UI 的加载，错误和数据属性。 我们来看一个例子：</p>
<p>首先，让我们创建 GraphQL 查询。 请记住将查询字符串包装在 <code>gql</code> 函数中，以便将其解析为查询文档。 一旦我们创建好 GraphQL 查询，让我们通过将它传递给 <code>query</code> prop 来将它附加到我们的 <code>Query</code> 组件。</p>
<p>我们还需要为 <code>Query</code> 组件提供一个子函数，它将告诉 React 我们想要呈现什么。 我们可以使用 <code>Query</code> 组件为我们提供的 <code>loading</code>，<code>error</code> 和 <code>data</code> 属性，以便根据查询的状态智能地呈现不同的 UI。 让我们看看这是什么样的！</p>
<pre><code class="language-jsx">import gql from &quot;graphql-tag&quot;;
import { Query } from &quot;react-apollo&quot;;

const GET_DOGS = gql`
  {
    dogs {
      id
      breed
    }
  }
`;

const Dogs = ({ onDogSelected }) =&gt; (
  &lt;Query query={GET_DOGS}&gt;
    {({ loading, error, data }) =&gt; {
      if (loading) return &quot;Loading...&quot;;
      if (error) return `Error! ${error.message}`;

      return (
        &lt;select name=&quot;dog&quot; onChange={onDogSelected}&gt;
          {data.dogs.map(dog =&gt; (
            &lt;option key={dog.id} value={dog.breed}&gt;
              {dog.breed}
            &lt;/option&gt;
          ))}
        &lt;/select&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
<p>如果你在 <code>App</code> 组件中渲染 <code>Dogs</code>，一旦 Apollo Client 从服务器接收数据，你将首先看到加载状态，然后是带有狗品种列表的表单。 当表单值改变时，我们将通过 <code>this.props.onDogSelected</code> 将值发送给父组件， 最终将值传递给 <code>DogPhoto</code> 组件。</p>
<p>在下一步中，我们将通过构建一个 <code>DogPhoto</code> 组件将表单挂载到一个更复杂的变量查询。</p>
<h2 id="接收数据">接收数据</h2>
<p>您已经在 render prop 函数中看到了如何处理查询结果。 当我们从 <code>Query</code> 组件中获取数据时，让我们深入了解 Apollo Client 幕后发生的事情。</p>
<ol>
<li>当 <code>Query</code> 组件安装时，Apollo Client 会为我们的查询创建一个 observable。 我们的组件通过 Apollo Client 缓存订阅查询结果。</li>
<li>首先，我们尝试 从 Apollo 缓存加载查询结果。 如果缓存中不存在，我们将请求发送到服务器。</li>
<li>一旦数据返回，我们将其标准化并将其存储在 Apollo 缓存中。 由于 <code>Query</code> 组件订阅了结果，因此它会自动更新数据。</li>
</ol>
<p>要查看 Apollo Client 的缓存操作，让我们构建我们的 <code>DogPhoto</code> 组件。 <code>DogPhoto</code> 接受一个名为 <code>breed</code> 的道具，它反映了上面 <code>Dogs</code> 组件中我们表单的当前值。</p>
<pre><code class="language-jsx">const GET_DOG_PHOTO = gql`
  query Dog($breed: String!) {
    dog(breed: $breed) {
      id
      displayImage
    }
  }
`;

const DogPhoto = ({ breed }) =&gt; (
  &lt;Query query={GET_DOG_PHOTO} variables={{ breed }}&gt;
    {({ loading, error, data }) =&gt; {
      if (loading) return null;
      if (error) return `Error!: ${error}`;

      return (
        &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
<p>您会注意到 <code>Query</code> 组件上有一个新的配置选项。 prop<code>variable</code> 是一个包含我们想要传递给 GraphQL 查询的变量对象。 在这种情况下，我们希望将表格中的品种传递给我们的查询。</p>
<p>尝试从列表中选择 &quot;bulldog&quot; 以查看其照片显示。 然后，切换到另一个品种并切换回 &quot;bulldog&quot;。 你会注意到牛头犬照片第二次瞬间加载。 这是 Apollo 缓存在起作用！</p>
<p>接下来，让我们学习一些确保数据新鲜的技术，例如轮询和重新获取。</p>
<h2 id="轮询和重新获取">轮询和重新获取</h2>
<p>Apollo Client 为您缓存数据真是太棒了，但是当我们需要新数据时我们应该怎么做？ 两种解决方案是轮询和重新获取。</p>
<p>轮询可以通过在指定的时间间隔内重新获取来帮助我们实现接近实时的数据。 要实现轮询，只需将 <code>pollInterval</code> prop传递给 <code>Query</code> 组件，间隔为 ms。 如果传入 0，查询将不会轮询。 您还可以通过在传递给 render prop 函数的结果对象上使用 <code>startPolling</code> 和 <code>stopPolling</code> 函数来实现动态轮询。</p>
<pre><code class="language-jsx">const DogPhoto = ({ breed }) =&gt; (
  &lt;Query
    query={GET_DOG_PHOTO}
    variables={{ breed }}
    skip={!breed}
    pollInterval={500}
  &gt;
    {({ loading, error, data, startPolling, stopPolling }) =&gt; {
      if (loading) return null;
      if (error) return `Error!: ${error}`;

      return (
        &lt;img src={data.dog.displayImage} style={{ height: 100, width: 100 }} /&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
<p>通过将 <code>pollInterval</code> 设置为 500 ，您应该每隔 0.5 秒看到一个新的狗图像。 轮询是实现近实时数据的绝佳方式，而无需复杂的设置 GraphQL 订阅。</p>
<p>如果要重新加载查询以响应用户操作而不是间隔，该怎么办？ 这就是 <code>refetch</code> 函数的用武之地！ 在这里，我们在 <code>DogPhoto</code> 组件中添加了一个按钮，该按钮会在单击时触发重新获取。<code>refetch</code> 接受变量，但如果我们不传入新变量，它将使用我们之前查询中的相同变量。</p>
<pre><code class="language-jsx">const DogPhoto = ({ breed }) =&gt; (
  &lt;Query
    query={GET_DOG_PHOTO}
    variables={{ breed }}
    skip={!breed}
  &gt;
    {({ loading, error, data, refetch }) =&gt; {
      if (loading) return null;
      if (error) return `Error!: ${error}`;

      return (
        &lt;div&gt;
          &lt;img
            src={data.dog.displayImage}
            style={{ height: 100, width: 100 }}
          /&gt;
          &lt;button onClick={() =&gt; refetch()}&gt;Refetch!&lt;/button&gt;
        &lt;/div&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
<p>如果单击该按钮，您会注意到我们的 UI 更新了最新的数据。 重新获取是保证新数据的一种很好的方法，但它在加载状态时引入了一些额外的复杂性。 在下一节中，您将学习处理复杂加载和错误状态的策略。</p>
<h2 id="加载和错误状态">加载和错误状态</h2>
<p>我们已经看到 Apollo Client 如何在渲染函数中公开我们的查询的加载和错误状态。 这些属性对于初次查询加载时有用，但是当我们重新获取或轮询时，我们的加载状态会发生什么？</p>
<p>让我们回到上一节中的示例。 如果单击 “Refetch” 按钮，您将看到组件在新数据到达之前不会重新呈现。 如果我们想向用户表明我们正在重新获取照片怎么办？</p>
<p>幸运的是，Apollo Client 通过 render prop 函数中结果对象的 <code>networkStatus</code> 属性提供有关查询状态的细粒度信息。 我们还需要将 prop 的 notifyOnNetworkStatusChange 设置为 true ，以便我们的查询组件在重新加载时重新渲染。</p>
<pre><code class="language-jsx">const DogPhoto = ({ breed }) =&gt; (
  &lt;Query
    query={GET_DOG_PHOTO}
    variables={{ breed }}
    skip={!breed}
    notifyOnNetworkStatusChange
  &gt;
    {({ loading, error, data, refetch, networkStatus }) =&gt; {
      if (networkStatus === 4) return &quot;Refetching!&quot;;
      if (loading) return null;
      if (error) return `Error!: ${error}`;

      return (
        &lt;div&gt;
          &lt;img
            src={data.dog.displayImage}
            style={{ height: 100, width: 100 }}
          /&gt;
          &lt;button onClick={() =&gt; refetch()}&gt;Refetch!&lt;/button&gt;
        &lt;/div&gt;
      );
    }}
  &lt;/Query&gt;
);
</code></pre>
<p><code>networkStatus</code> 属性是一个枚举，其数字值为 1-8，表示不同的加载状态。 4 对应重新获取，但也有用于轮询和分页的数字值。 有关所有可能加载状态的完整列表，请查看<a href="../api/react-apollo.html#graphql-query-data-networkStatus">参考指南</a>。</p>
<p>虽然没有加载状态那么复杂，但是也可以通过 <code>Query</code> 组件上的 <code>errorPolicy</code> prop 来自定义组件中的错误。 <code>errorPolicy</code> 的默认值是 “none” ，我们将所有 GraphQL 错误视为运行时错误。 如果发生错误，Apollo Client 将丢弃随请求返回的任何数据，并将 render prop 函数中的 <code>error</code> 属性设置为 true。 如果您想显示任何部分数据以及任何错误信息，请将 <code>errorPolicy</code> 设置为 “all”。</p>
<h2 id="手动触发查询">手动触发查询</h2>
<p>当 React 安装一个 <code>Query</code> 组件时，Apollo Client 会自动触发你的查询。 如果您想延迟触发查询，直到用户执行操作（例如单击按钮），该怎么办？ 对于这种情况，我们想要使用 <code>ApolloConsumer</code> 组件并直接调用 <code>client.query()</code>。</p>
<pre><code class="language-jsx">import React, { Component } from 'react';
import { ApolloConsumer } from 'react-apollo';

class DelayedQuery extends Component {
  state = { dog: null };

  onDogFetched = dog =&gt; this.setState(() =&gt; ({ dog }));

  render() {
    return (
      &lt;ApolloConsumer&gt;
        {client =&gt; (
          &lt;div&gt;
            {this.state.dog &amp;&amp; &lt;img src={this.state.dog.displayImage} /&gt;}
            &lt;button
              onClick={async () =&gt; {
                const { data } = await client.query({
                  query: GET_DOG_PHOTO,
                  variables: { breed: &quot;bulldog&quot; }
                });
                this.onDogFetched(data.dog);
              }}
            &gt;
              Click me!
            &lt;/button&gt;
          &lt;/div&gt;
        )}
      &lt;/ApolloConsumer&gt;
    );
  }
}
</code></pre>
<p>以这种方式获取是非常冗长的，所以我们建议尽可能使用 <code>Query</code> 组件！</p>
<blockquote>
<p>如果您想查看我们刚刚构建的应用程序的完整版本，您可以查看CodeSandbox <a href="https://codesandbox.io/s/n3jykqpxwm">此处</a>.</p>
</blockquote>
<h2 id="query-api-概览">Query API 概览</h2>
<p>如果您正在寻找所有 <code>Query</code> 组件接受及其渲染方法功能的概述，请不要再看了！ 大多数 <code>Query</code> 组件不需要所有这些配置选项，但知道它们存在是有用的。 如果您想通过使用示例更详细地了解 <code>Query</code> 组件 API，请访问我们的<a href="../api/react-apollo.html">参考指南</a>.</p>
<h3 id="props">Props</h3>
<p>Query 组件接受以下 props。 只有 <code>query</code> 和 <code>children</code>是必须的 <strong>required</strong>.</p>
<dl>
  <dt>`query`: DocumentNode</dt>
  <dd>GraphQL查询文档通过`graphql-tag`解析为AST。 **Required**</dd>
  <dt>`children`: (result: QueryResult) => React.ReactNode</dt>
  <dd>一个函数，根据查询结果返回要渲染的 UI。**Required**</dd>
  <dt>`variables`: { [key: string]: any }</dt>
  <dd>包含执行查询需要的所有变量对象</dd>
  <dt>`pollInterval`: number</dt>
  <dd>指定组件轮询数据的时间间隔（以毫秒为单位）。 默认为 0（无轮询）。</dd>
  <dt>`notifyOnNetworkStatusChange`: boolean</dt>
  <dd>是否更新网络状态或网络错误应重新呈现组件。 默认为false。</dd>
  <dt>`fetchPolicy`: FetchPolicy</dt>
  <dd>您希望组件如何与 Apollo 缓存交互。 默认为 “cache-first”。</dd>
  <dt>`errorPolicy`: ErrorPolicy</dt>
  <dd>您希望组件如何处理网络和 GraphQL 错误。 默认为 “none”，这意味着我们将 GraphQL 错误视为运行时错误。</dd>
  <dt>`ssr`: boolean</dt>
  <dd>传入 false 以在服务端渲染期间跳过查询。</dd>
  <dt>`displayName`: string</dt>
  <dd>要在 React DevTools 中显示的组件的名称。 默认为 'Query'。</dd>
  <dt>`skip`: boolean</dt>
  <dd>如果 skip 为 true，则将完全跳过查询。</dd>
  <dt>`onCompleted`: (data: TData | {}) => void</dt>
  <dd>查询成功完成后执行的回调。</dd>
  <dt>`onError`: (error: ApolloError) => void</dt>
  <dd>发生错误时执行的回调。</dd>
  <dt>`context`: Record<string, any></dt>
  <dd>查询组件与网络接口（Apollo Link）之间的共享上下文。 用于从道具设置标题或将信息发送到 Apollo Boost 的 `request` 功能。</dd>
  <dt>`partialRefetch`: boolean</dt>
  <dd>如果是 `true`，如果查询结果被标记为部分，则执行查询 `refetch`，并且由 Apollo Client `QueryManager` 将返回的数据重置为空对象（由于高速缓存未命中）。 出于向后兼容性的原因，默认值为 “false”，但对于大多数实例，应将其更改为true。</dd>
</dl>
<h3 id="render-prop-function">Render prop function</h3>
<p>使用具有以下属性的对象（<code>QueryResult</code>）调用传递给 <code>Query</code> 的 <code>children</code> prop 的 render prop 函数。 此对象包含您的查询结果，以及一些有用的函数，用于重新获取，动态轮询和分页。</p>
<dl>
  <dt>`data`: TData</dt>
  <dd>包含 GraphQL 查询结果的对象。 默认为空对象。</dd>
  <dt>`loading`: boolean</dt>
  <dd>一个布尔值，指示请求是否在执行中</dd>
  <dt>`error`: ApolloError</dt>
  <dd>使用 `graphQLErrors` 和 `networkError` 属性的运行时错误</dd>
  <dt>`variables`: { [key: string]: any }</dt>
  <dd>包含调用查询的变量对象</dd>
  <dt>`networkStatus`: NetworkStatus</dt>
  <dd>1-8 之间的数字，对应网络请求的详细状态。 包括有关重新获取和轮询状态的信息。 与 `notifyOnNetworkStatusChange` 道具一起使用。
</dd>
  <dt>`refetch`: (variables?: TVariables) => Promise<ApolloQueryResult></dt>
  <dd>一个允许您重新获取查询并可选地传入新变量的函数</dd>
  <dt>`fetchMore`: ({ query?: DocumentNode, variables?: TVariables, updateQuery: Function}) => Promise<ApolloQueryResult></dt>
  <dd>为您的查询启用 [pagination](../features/pagination.html) 的函数</dd>
  <dt>`startPolling`: (interval: number) => void</dt>
  <dd>此函数以 ms 为单位设置间隔，并在每次指定的间隔通过时获取查询。</dd>
  <dt>`stopPolling`: () => void</dt>
  <dd>此函数停止查询轮询。</dd>
  <dt>`subscribeToMore`: (options: { document: DocumentNode, variables?: TVariables, updateQuery?: Function, onError?: Function}) => () => void</dt>
  <dd>设置 [subscription](../advanced/subscriptions.html) 的函数。 `subscribeToMore` 返回一个可用于取消订阅的函数。</dd>
  <dt>`updateQuery`: (previousResult: TData, options: { variables: TVariables }) => TData</dt>
  <dd>函数，允许您在获取，变异或订阅的上下文之外的缓存中更新查询的结果</dd>
  <dt>`client`: ApolloClient</dt>
  <dd>你的 'ApolloClient` 实例。 用于手动触发查询或将数据写入。</dd>
</dl>
<h2 id="下一步">下一步</h2>
<p>学习如何构建 <code>Query</code> 组件来获取数据是掌握 Apollo Client 开发的最重要技能之一。 既然您是获取数据的专家，为什么不尝试构建 <code>Mutation</code> 组件来更新您的数据？ 以下是我们认为可以帮助您提升技能的一些资源：</p>
<ul>
<li><a href="./mutations.html">Mutations</a>: 了解如何使用突变更新数据以及何时需要更新 Apollo 缓存。 有关选项的完整列表，请查看 <code>Mutation</code> 组件的API参考。</li>
<li><a href="./local-state.html">Local state management</a>: 学习如何使用 <code>apollo-link-state</code> 查询本地数据。</li>
<li><a href="../features/pagination.html">Pagination</a>: 基于 Apollo Client 的 <code>fetchMore</code> 功能，构建列表从未如此简单。 在我们的分页教程中了解更多信息。</li>
<li><a href="https://youtu.be/YHJ2CaS0vpM">Query component video by Sara Vieira</a>: 如果您需要通过观看视频进行复习或学习，请查看 Sara 的 <code>Query</code> 组件的教程！</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gitlab-CI前端持续集成]]></title>
        <id>http://fanguyun214.github.io/post/gitlab-ci-qian-duan-chi-xu-ji-cheng</id>
        <link href="http://fanguyun214.github.io/post/gitlab-ci-qian-duan-chi-xu-ji-cheng">
        </link>
        <updated>2019-07-18T10:15:48.000Z</updated>
        <summary type="html"><![CDATA[<p>gitlab-ci 全称是 gitlab continuous integration，也就是基于gitlab的持续集成工具。</p>
]]></summary>
        <content type="html"><![CDATA[<p>gitlab-ci 全称是 gitlab continuous integration，也就是基于gitlab的持续集成工具。</p>
<!-- more -->
<h2 id="1-gitlab-ci-gitlab-ci-runner">1、Gitlab-ci &amp;&amp; Gitlab-ci-runner</h2>
<p><strong>gitlab-ci</strong></p>
<p>中心思想是当每一次push到gitlab的时候，都会触发一次脚本执行，然后脚本的内容包括了测试，编译，部署等一系列自定义的内容。高版本的 GitLab 自带了 GitLab CI，所以不需要另外安装。</p>
<p><strong>GitLab-Runner</strong></p>
<p>GitLab-Runner 是脚本执行的承载者，GitLab-CI 事先注册好 GitLab-Runner，再 push 代码，对应的 Runner 就会执行你所定义的脚本。</p>
<p><strong>本地push -&gt; .gitlab-ci.yml配置 -&gt; GitLab-Runner执行脚本 -&gt; 部署开发、测试、生产服务器</strong></p>
<h2 id="2-安装gitlab-runner">2、安装GitLab-Runner</h2>
<p>Gitlab Runner安装方式有两种，一种是直接二进制文件安装，一种是基于docker镜像安装。</p>
<p><strong>二进制文件安装</strong></p>
<ul>
<li>下载对应操作系统的二进制包，我这里使用的是mac版本，</li>
</ul>
<pre><code>sudo curl --output /usr/local/bin/gitlab-ci-multi-runner https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-ci-multi-runner-darwin-amd64
</code></pre>
<ul>
<li>给 gitlab-ci-multi-runner 设置权限</li>
</ul>
<pre><code>sudo chmod +x /usr/local/bin/gitlab-ci-multi-runner
</code></pre>
<p>以上是官方安装文档，如果有问题，可以手动到<a href="https://gitlab-ci-multi-runner-downloads.s3.amazonaws.com/v1.11.2/index.html">版本下载列表</a>下载对应的版本，然后复制到/usr/local/bin/目录下</p>
<ul>
<li>注册runner<br>
首先，进入到你的 gitlab 项目网页，找到 Settings -&gt; CI/CD -&gt; Runner，然后找到对应的 url 和 token</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2940147be83f1?w=901&amp;h=557&amp;f=png&amp;s=127905" alt=""></p>
<p>然后在终端输入</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2941c0497ad6f?w=1071&amp;h=379&amp;f=png&amp;s=157806" alt=""><br>
依次是url,token,描述,tag,是否共享,执行方式</p>
<p>启动Runner，<code>gitlab-ci-multi-runner start</code>，刷新页面</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2948a0bcf3446?w=494&amp;h=190&amp;f=png&amp;s=17239" alt=""><br>
说明注册成功了。</p>
<p>我们可以通过 gitlab-ci-multi-runner list 查询你注册的runner ，用 gitlab-ci-multi-runner status 查看 runner 服务是否运行中。</p>
<p><strong>基于Docker安装</strong></p>
<ul>
<li>先获取 gitlab-runner 镜像</li>
</ul>
<pre><code>sudo docker pull gitlab/gitlab-runner:latest
</code></pre>
<ul>
<li>启动 gitlab-runner container</li>
</ul>
<pre><code>sudo docker run -d --name gitlab-runner --restart always \
  -v /srv/gitlab-runner/config:/etc/gitlab-runner \
  -v /var/run/docker.sock:/var/run/docker.sock \
  gitlab/gitlab-runner:latest
</code></pre>
<ul>
<li>注册runner</li>
</ul>
<pre><code>sudo docker exec -it gitlab-runner gitlab-ci-multi-runner register
注册方式同上
</code></pre>
<h2 id="3-配置gitlab-ciyml">3、配置.gitlab-ci.yml</h2>
<p>GitLab CI的一切工作，都是由 .gitlab-ci.yml 来配置的。详细文档可以参考<a href="https://docs.gitlab.com/ee/ci/yaml/README.html">这里</a></p>
<p>在项目根目录下创建 .gitlab-ci.yml 文件</p>
<pre><code># 设置缓存
cache:
  paths:
    - node_modules/
    - dist/
# 定义 stages，用来定义工作阶段，多个 stages 会按顺序进行
stages:
  - build
  - test
  - deploy
# before_script 会在每个 stages 执行之前运行
before_script:
  - node -v
  - yarn --version
  - yarn global add umi
  - yarn install
  
# 测试（对应上面stages）
test:
  stage: test
  script:
    - echo 'yarn test'
    - yarn test
# 构建
build:
  stage: build
  script:
    - echo 'yarn build'
    - yarn build
  when: manual # 手动触发
# 部署
deploy:
  stage: deploy
  only:
    - master
  script:
    - bash scripts/deploy.sh # 部署脚本文件
  when: manual
</code></pre>
<p>配置完成提交Gitpab后，每次push都会触发gitlab-ci。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/17/16a2955cb45a52b4?w=1048&amp;h=243&amp;f=png&amp;s=46518" alt=""></p>
<h2 id="4参考资料">4.参考资料</h2>
<ul>
<li><a href="https://docs.gitlab.com/runner/install/osx.html">gitlab-runner 安装</a></li>
<li><a href="https://docs.gitlab.com/ee/ci/yaml/README.html">gitlab ci yaml 配置</a></li>
<li><a href="https://www.jianshu.com/p/df433633816b">【后端】gitlab之gitlab-ci自动部署</a></li>
<li><a href="https://juejin.im/post/5d00acd26fb9a07eca69745b">前端基于SSH的自动部署</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端基于SSH的自动部署]]></title>
        <id>http://fanguyun214.github.io/post/qian-duan-ji-yu-ssh-de-zi-dong-bu-shu</id>
        <link href="http://fanguyun214.github.io/post/qian-duan-ji-yu-ssh-de-zi-dong-bu-shu">
        </link>
        <updated>2019-07-18T09:59:12.000Z</updated>
        <summary type="html"><![CDATA[<p>SSH是一种网络协议，用于计算机之间的加密登录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>SSH是一种网络协议，用于计算机之间的加密登录。</p>
<!-- more -->
<h3 id="ssh简介">ssh简介</h3>
<p>原理：</p>
<ul>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户。</li>
<li>用户使用这个公钥，将登录密码加密后，发送回来。</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ul>
<p>当远程主机的公钥被接受以后，它就会被保存在本地文件~/.ssh/known_hosts之中，此外系统也有一个这样的文件，通常是/etc/ssh/ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
<h3 id="常用指令">常用指令</h3>
<ul>
<li>本地登录服务器 ssh user@remote -p port，端口是22的话ssh user@remote，退出登录exit</li>
<li>本地免密码登录 ssh-copy-id user@remote -p port，这在写脚本服务器控制时特别有用</li>
<li>给服务器配置别名 code ~/.ssh/config追加一些内容，就可以ssh selfname登录，不再需要记服务器ip地址了</li>
<li>执行命令ssh selfname &quot;cd ~;ls&quot;，将会在服务器上执行引号里的命令，执行之后其自动关闭远程服务</li>
<li>将a电脑文件(夹)复制到b电脑上哪个文件夹下面：scp username@a电脑ip:文件路径 username@b电脑ip:文件夹路径，是文件夹的话加上-r，这里也可以用别名，通常本机的话省略username@a电脑ip:</li>
</ul>
<pre><code>ssh user@remote -p port

# user 是你在远程机器上的用户名，如果不指定的话默认为当前用户
# remote 是远程机器的地址，可以是 IP，域名，或者是后面会提到的别名
# port 是 SSH Server 监听的端口，如果不指定的话就为默认值 22
# 比如我常用的 ssh zhm@120.79.52.223

</code></pre>
<p>通常在本地电脑输入以上命令之后，远程服务器就会询问密码，你输入的时候是看不见任何波动，输入完回车就可以了~，如果报错ssh: connect to host remote port 22: Connection refused，说明服务器没有按照ssh server，Ubantu Desktop系统默认是没有这个的，安装命令sudo apt-get install openssh-server</p>
<h3 id="免密登录">免密登录</h3>
<p>每次 ssh 都要输入密码是不是很烦呢？与密码验证相对的，是公钥验证。也就是说，要实现免密码登入，首先要设置 SSH 钥匙。也就是本地电脑生成公钥私钥，然后把公钥放在远程服务器上就可以了！<br>
原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>
<pre><code># 查看本地有没有
ls ~/.ssh
# 没有就生成
ssh-keygen
# 在~/.ssh/目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。
# 把公钥放到远程服务器
ssh-copy-id user@remote -p port
# 比如我的 ssh-copy-id zhm@120.79.52.223

</code></pre>
<p>ssh-copy-id基本都安装了，万一没有，mac上brew install ssh-copy-id。<br>
windows麻烦点ssh user@remote -p port 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub，意思是在远端执行新建 .ssh 文件夹，并把本地的 ~/.ssh/id_rsa.pub （也就是公钥）追加到远端的 .ssh/authorized_keys 中。当然，不使用这条命令的话，你也可以手动操作这个过程，即先复制公钥，再登入远程机器，粘贴到 .ssh/authorized_keys 当中。</p>
<h3 id="配置别名">配置别名</h3>
<p>每次都输入 ssh user@remote -p port，时间久了也会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆的时候。配置别名可以让我们进一步偷懒。比如我想用ssh lab替换上面一串</p>
<pre><code># cat&gt;&gt;某文件&lt;&lt;EOF追加下内容， &gt;&gt; 追加的意思 &lt;&lt;EOF 遇到EOF终止
# 因为是前端，直接用vscode编辑
code ~/.ssh/config
# 追加以下内容，保存
Host lab
    HostName remote
    User user
    Port port

# 来登录吧
ssh lab

# 比如我的
# Host han
    # HostName 120.79.52.223
    # User zhm
    # Port 22
# ssh han
</code></pre>
<h3 id="命令行执行登录并且在目标服务器上执行命令">命令行执行登录并且在目标服务器上执行命令</h3>
<p>命令行执行登录并且在目标服务器上执行命令:</p>
<pre><code># 单引号或者双引号，将命令包起来，然后分号隔开命令
ssh user@remoteNode &quot;cd /home ; ls&quot;
</code></pre>
<p>如果是很多命令的话，需要建一个脚本。</p>
<pre><code># 建一个脚本文件test.sh，里面写上这个，然后执行 sh test.sh
#!/bin/bash  
# 远程执行的内容在&quot;&lt; &lt; remotessh &quot; 至&quot; remotessh &quot;之间，如果不想本机出现日志的话 ssh user@remoteNode &gt;/dev/null 2&gt;&amp;1   &lt;&lt; remotessh
ssh user@remoteNode &lt;&lt; remotessh
ls
exit
remotessh
</code></pre>
<h3 id="传输文件">传输文件</h3>
<p>两台机器间文件传输可以用scp，它的地址格式与 ssh 基本相同，都是可以省略用户名和端口，稍微的差别在与指定端口时用的是大写的 -P 而不是小写的。不过，如果你已经配置了别名，那么这都不重要，因为 scp 也支持直接用别名</p>
<pre><code># 总的：本机的可以省略电脑的ip，默认的远程当前文件夹是 Home目录（~），将A电脑上的文件复制到B电脑上
# 注意的地方：A若是文件，B电脑若也是文件的路径，不管文件存不存在，都会将A文件内容写入到B这个文件。
#                    B电脑若是文件夹，不管文件夹存不存在，都会在这个文件夹下生成A电脑同名的文件和内容，有的话则会覆盖同名文件
# A若是文件夹，加上-r，B电脑若是文件的路径会报错，B电脑若是文件夹路径，文件夹不存在的话则会建立这个文件夹且放入A文件夹里面的内容（相当于将A文件夹挪过去然后重命名），文件夹存在的话，会在这个文件夹下面生成一个和A同名的文件夹，里面内容一致
scp A电脑:文件路径 B电脑:文件路径

# 把本地的 /path/to/local/file 文件传输到远程的 /path/to/remote/file  
scp -P port /path/to/local/file user@remote:/path/to/remote/file

# 也可以使用别名
scp /path/to/local/file lab:/path/to/remote/file

# 把远程的 /path/to/remote/file 下载到本地的 /path/to/local/file
scp lab:/path/to/remote/file /path/to/local/file

# 远程的默认路径是家目录
# 下面命令把当前目录下的 file 传到远程的 ~/dir/file
scp file lab:dir/file

# 加上 -r 命令可以传送文件夹
# 下面命令可以把当前目录下的 dir 文件夹传到远程的家目录下
scp -r dir lab:

# 别忘了 . 可以用来指代当前目录
# 下面命令可以把远程的 ~/dir 目录下载到当前目录里面
scp -r lab:dir/ .
</code></pre>
<p>如果觉得使用命令行传输文件浑身不自在，你还可以使用 SFTP 协议。任何支持 SFTP 协议的客户端都能用你的 SSH 账号信息登入并管理文件，比如开源的有图形化界面的FTP客户端 FileZilla。别忘了，在这些客户端里面，你也可以指定你的私钥（~/.ssh/id_rsa），然后就能做到无密码登入了。</p>
<h3 id="保持程序在后台运行">保持程序在后台运行</h3>
<p>以下命令均在服务器执行</p>
<h4 id="nohup">nohup</h4>
<pre><code># 让程序在后台运行 比如 nohup node index.js &amp;
nohup 一直执行的命令 &amp;
# 看下任务号 node的那个
ps
# 如果需要终止的话
kill 21455
</code></pre>
<h4 id="tmux">tmux</h4>
<p>tmux更能执行复杂的程序，tmux还能管理多个窗口，窗口切分，复制粘贴等等，mac用户使用tmux更方便，新建会话tmux -CC，恢复的时候tmux -CC attach</p>
<pre><code># 服务器上安装tmux
sudo apt-get install tmux

# 运行tmux，进入会话，此时运行任何东西都不会因为退出ssh而被杀死
tmux

# 暂时离开会话 ctrl+b 再按下d

# 恢复会话
# tmux attach

# tmux命令必须运行在服务器上
</code></pre>
<p>以上内容来自<a href="https://juejin.im/post/5ce4a082e51d4577583ddc24">ssh免密登录服务器和scp的使用</a></p>
<h3 id="基于rsync的部署">基于rsync的部署</h3>
<p>参考<a href="https://segmentfault.com/a/1190000015669114">rsync 的使用方法</a></p>
<h3 id="scp和rsync的区别">scp和rsync的区别</h3>
<h4 id="scp命令">scp命令</h4>
<p>1.scp 是 secure copy 的缩写，用于远程的文件的复制。</p>
<p>2.参数：</p>
<pre><code>-r： 递归复制整个目录。
</code></pre>
<p>3.实例：</p>
<pre><code>scp /home/space/music/1.mp3 username@ip/home/root/others/music     
scp /home/space/music/1.mp3 username@ip/home/root/others/music/001.mp3
</code></pre>
<p>如果是远程复制目录就加上 -r 参数 即可（重命名目录，就直接在命令后面添加，前提保证目标地址没有该目录）</p>
<pre><code>scp -r /home/space/music/ username@ip:/home/root/others/music_new
</code></pre>
<p>把本地music目录复制到另一台服务器的others下，并重命名为music_new</p>
<h4 id="rsync">rsync</h4>
<p>1.rsync 是 remote sync 的缩写，用于linux系统下的数据镜像备份工具，远程服务器之间的文件拷贝。<br>
2.参数：</p>
<pre><code>-a, --archive 归档模式，表示以递归方式传输文件，并保持所有文件属性，等于-rlptgoD。
-v, --verbose 详细模式输出。
-z, --compress 对备份的文件在传输时进行压缩处理。
-P, --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。
</code></pre>
<p>3.实例：</p>
<pre><code>rsync -avp mylog /home/
</code></pre>
<p>scp是相当于复制，黏贴，如果有的话是覆盖，比较耗时间，不智能。</p>
<p>rsync是复制，如果有重复的文件，会直接跳过，而且他自己的算法优化。</p>
<p>scp是把文件全部复制过去，当文件修改后还是把所有文件复制过去，rsync 第一次是把所有文件同步过去，当文件修改后，只把修改的文件同步过去。</p>
<h3 id="前端基于scp或rsync的自动部署">前端基于scp或rsync的自动部署</h3>
<p>1、基于scp,新增部署脚本文件，如deploy.sh</p>
<pre><code># 压缩文件，其中 dist为要上传的文件所在目录
echo 压缩部署包！
tar -zcvf dist.tar.gz dist/

# 上传到服务器（需要输入密码，如果已经进行过私钥配置，则不用），其中/home/savoygu/gusaifei 为上传文件所在目录
echo 上传文件
scp -r dist.tar.gz 账号@服务器ip:服务器上传路径

# 登录到服务器（需要输入密码，如果已经进行过私钥配置，则不用）
# 服务器环境开启
ssh 账号@服务器ip -tt &lt;&lt; EOF

# 进入目标目录
cd 服务器上传路径
# 解压
sudo tar -zxvf dist.tar.gz --strip-components 1
# 移除线上压缩文件
sudo rm -rf

exit
EOF
# 服务器环境结束
echo 上传完成！

# 移除本地压缩文件
echo 删除本地压缩包！
rm -rf dist.tar.gz
</code></pre>
<p>使用rsync同理</p>
<p>2、前端使用脚本</p>
<pre><code>  &quot;scripts&quot;: {
    &quot;deploy&quot;: &quot;cross-env NODE_ENV=production umi build &amp;&amp; ./deploy.sh&quot;
  }
</code></pre>
<p>可结合gitlabCI，Travis CI实现持续集成，参考</p>
<ul>
<li><a href="https://juejin.im/post/5cb693b66fb9a0687a1719d3">持续集成服务 gitlabCI教程</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html">持续集成服务 Travis CI教程</a></li>
</ul>
<h3 id="错误处理">错误处理</h3>
<p>1、权限问题</p>
<pre><code>.ssh目录，以及/home/当前用户 需要700权限，参考以下操作调整
sudo chmod 700 ~/.ssh
sudo chmod 700 /home/当前用户
.ssh目录下的authorized_keys文件需要600或644权限，参考以下操作调整
sudo chmod 600 ~/.ssh/authorized_keys
</code></pre>
<p>2、StrictModes问题</p>
<pre><code>编辑
sudo vi /etc/ssh/sshd_config
找到
#StrictModes yes
改成
StrictModes no
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用commitizen的正确姿势 ]]></title>
        <id>http://fanguyun214.github.io/post/shi-yong-commitizen-de-zheng-que-zi-shi</id>
        <link href="http://fanguyun214.github.io/post/shi-yong-commitizen-de-zheng-que-zi-shi">
        </link>
        <updated>2019-07-18T06:52:44.000Z</updated>
        <summary type="html"><![CDATA[<p>我们在每次提交代码时，都需要编写Commit Message，否则是不允许提交的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们在每次提交代码时，都需要编写Commit Message，否则是不允许提交的。</p>
<!-- more -->
<pre><code>git commit -m “first commit with userInfo service”
</code></pre>
<p>编写Commit Message需要遵循一定的范式，内容应该清晰明了，指明本次提交的目的，便于日后追踪问题。<br>
commitizen就是这么样一款工具,他用来规范化我们的commit消息。</p>
<h3 id="安装指南">安装指南</h3>
<p>安装commitizen</p>
<pre><code>sudo npm install -g commitizen
</code></pre>
<h3 id="配置">配置</h3>
<p>cd到.git所在目录</p>
<pre><code>commitizen init cz-conventional-changelog --save --save-exact
</code></pre>
<p>使用<br>
用git cz命令来取代git commit</p>
<pre><code> npm install --global cz-emoji
 set as default adapter for your projects
 echo '{ &quot;path&quot;: &quot;cz-emoji&quot; }' &gt; ~/.czrc
</code></pre>
<h3 id="异常情况">异常情况</h3>
<p>有可能提示你缺少package.json<br>
配置第二个项目<br>
当我们配置第二个项目的时候我们只需要进入到对应的.git文件夹下，输入如下的命令</p>
<pre><code>commitizen init cz-conventional-changelog --force
</code></pre>
<p>我们就可以使用git cz命令了</p>
<h3 id="commitizen详解">commitizen详解</h3>
<pre><code>Message 格式
一般来说，Commit Message 应包含三部分内容：Header、Body、Footer
&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
&lt;body&gt;
&lt;footer&gt;
Header
Header部分应只包含一行，包括三个字段：type、scope和subject
type type用于说明Commit的类型，包含一下7种类型
    feat：新功能（feature）
    fix：修补bug
    docs：文档（documentation）
    style： 格式（不影响代码运行的变动）
    refactor：重构（即不是新增功能，也不是修改bug的代码变动）
    test：增加测试
    chore：构建过程或辅助工具的变动

scope
    scope用于说明本次Commit所影响的范围，比如controller、user或者README，视项目的不同而不同
subject
subject是本次Commit目的的简短描述，一般不要超过50个字符
    以动词开头，使用第一人称现在时，比如change，而不是changed或changes
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redux简介]]></title>
        <id>http://fanguyun214.github.io/post/redux-jian-jie</id>
        <link href="http://fanguyun214.github.io/post/redux-jian-jie">
        </link>
        <updated>2019-07-18T03:46:11.000Z</updated>
        <summary type="html"><![CDATA[<p>redux 是一个状态管理器，redux 和 react 没有关系，redux 可以用在任何框架中，忘掉 react。</p>
]]></summary>
        <content type="html"><![CDATA[<p>redux 是一个状态管理器，redux 和 react 没有关系，redux 可以用在任何框架中，忘掉 react。</p>
 <!-- more --> 
<p>connect 不属于 redux，它其实属于 react-redux。</p>
<p>请一定先忘记 reducer、store、dispatch、middleware 等等这些名词。</p>
<p><strong>createStore</strong></p>
<p>创建 store 对象，包含 getState, dispatch, subscribe, replaceReducer</p>
<p><strong>reducer</strong></p>
<p>reducer 是一个计划函数，接收旧的 state 和 action，生成新的 state</p>
<p><strong>action</strong></p>
<p>action 是一个对象，必须包含 type 字段</p>
<p><strong>dispatch</strong></p>
<p>dispatch( action ) 触发 action，生成新的 state</p>
<p><strong>subscribe</strong></p>
<p>实现订阅功能，每次触发 dispatch 的时候，会执行订阅函数</p>
<p><strong>combineReducers</strong></p>
<p>多 reducer 合并成一个 reducer</p>
<p><strong>replaceReducer</strong></p>
<p>替换 reducer 函数</p>
<p><strong>middleware</strong></p>
<p>扩展 dispatch 函数！</p>
<p><strong>Redux流程图</strong></p>
<p><img src="http://fanguyun214.github.io/post-images/1563424647611.jpg" alt="Redux流程图"></p>
]]></content>
    </entry>
</feed>